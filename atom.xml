<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>crAzyli0n&#39;s blog</title>
  <icon>https://www.gravatar.com/avatar/b3d44b3841a490b229772bd744d55972</icon>
  <subtitle>记录前进中的点点滴滴</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xidianpanpei.github.io/"/>
  <updated>2017-11-13T11:34:53.942Z</updated>
  <id>http://xidianpanpei.github.io/</id>
  
  <author>
    <name>crAzyli0n</name>
    <email>pannpei@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Windows终端环境搭建</title>
    <link href="http://xidianpanpei.github.io/2015/04/30/build-windows-work-environment/"/>
    <id>http://xidianpanpei.github.io/2015/04/30/build-windows-work-environment/</id>
    <published>2015-04-30T18:31:00.000Z</published>
    <updated>2017-11-13T11:34:53.942Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/7458d655gw1f8mezaqwutj21kw11z4qp.jpg" alt=""></p><p>最近已经入职了新的公司，不错的是公司给分配了配置还算不错的电脑。悲剧的是，操作系统是Windows7。之前使用Ubuntu的操作系统都已经快一年多了，都已经习惯了在Ubuntu下进行各个工作了，虽然在IM工具和Office工具上还是有些问题，但是影响还不至于很大。反倒是一下换回到了Windows环境下，反而有些不习惯了。</p><a id="more"></a><p>因为之前一直在从事云计算相关的开发与研究，所以会经常登录各种服务器，Ubuntu下的Terminal使用起来真的是很爽很方便。然而在Windows下，那个DOS Terminal一下子让我感受到了MS深深地恶意。没办法，只能自力更生，自己想办法解决了。之前是知道Cygwin的，而且也知道Cygwin有着些不足，并不是特别想用。于是在网上继续搜索着，终于找到一个叫做<a href="http://babun.github.io/" target="_blank" rel="external">Babun</a> 的软件。这东西是基于Cygwin做了层封装，但是做的还是挺好的，关键是居然还有一个Package Manager，这个真的是很难得的，更难得的是居然还有不少的软件可以安装。</p><p>首先是从Babun的<a href="http://babun.github.io/" target="_blank" rel="external">官网</a>下载Babun的安装包，Babun 默认安装在 %USER_HOME%.babun 目录，但是公司的电脑就C盘和D盘，而且C盘又小的可怜，没办法，只能将其安装到D盘了。解压Babun安装包，然后使用管理员权限打开cmd Dos界面，在安装包文件夹中执行以下命令即可：<br><code>install.bat /t &quot;D:\Babun&quot;</code></p><p>等到命令执行完毕，Babun也就顺利安装完成了，看上去是不是很简单的。但是刚刚安装完毕的Babun的界面还是只是经典Dos风格的，看上去还是很丑。然后没办法，我只能祭出之前在Ubuntu上修改Terminator的办法，使用Solarized Dark配色的配置方法加上dircolors将其修改的有点Linux终端的味道了。最后就是使用私家的<a href="https://github.com/xidianpanpei/dot-vimrc" target="_blank" rel="external">Vim配置</a> 调整好Vim。整个过程折腾下来还是有些麻烦的，但是总算能够在Windows上有一个可用的Terminal了。</p><p>最后祭上最终的Babun的截图，看上是不是蛮不错的！<br><img src="http://ww2.sinaimg.cn/large/7458d655gw1f70ojtmx8lj21270kadlo.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/7458d655gw1f8mezaqwutj21kw11z4qp.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近已经入职了新的公司，不错的是公司给分配了配置还算不错的电脑。悲剧的是，操作系统是Windows7。之前使用Ubuntu的操作系统都已经快一年多了，都已经习惯了在Ubuntu下进行各个工作了，虽然在IM工具和Office工具上还是有些问题，但是影响还不至于很大。反倒是一下换回到了Windows环境下，反而有些不习惯了。&lt;/p&gt;
    
    </summary>
    
      <category term="杂项" scheme="http://xidianpanpei.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="Babun" scheme="http://xidianpanpei.github.io/tags/Babun/"/>
    
      <category term="终端" scheme="http://xidianpanpei.github.io/tags/%E7%BB%88%E7%AB%AF/"/>
    
      <category term="工作环境" scheme="http://xidianpanpei.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title>百度系统工程师初面之经历</title>
    <link href="http://xidianpanpei.github.io/2014/10/08/baidu-interview/"/>
    <id>http://xidianpanpei.github.io/2014/10/08/baidu-interview/</id>
    <published>2014-10-08T18:14:33.000Z</published>
    <updated>2017-11-13T11:34:53.938Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/7458d655gw1f8mf6sbji1j21kw16okiv.jpg" alt=""><br>国庆长假刚刚过去，早晨还是迷迷糊糊的，还没有从长假休息状态恢复过来。正当眯着眼犯困的时候，手机很不应景的震动起来。结果是一个陌生的号码，接起来后才知道对方是百度的面试官，说是要我安排时间面试一下。考虑上午已经前往实习公司了，所以和对方约定了下午2:00面试。</p><a id="more"></a><p>中午和老大请了个假，让后匆匆赶回学校。因为面试官下榻的宾馆离学校比较近，所以中午在宿舍磨蹭了一会儿，到下午1:20才出门。步行了2公里左右就到了面试地点（真的好近啊！！！）。由于提前到了，于是给面试官发了个短信，很快面试官就出来把我引入面试房间，说是面试房间，其实就是面试官的宾馆房间。面试官年龄看上去并不是很大，人很nice。等到都坐定了之后，就开始准备面试了。</p><p>其实，这次根本没有想到还会有面试的机会，当时相当于霸笔了，而且当时觉得卷子答的很是糟糕，就认定了是无望了。面试官开始翻阅之前的考卷，问我那个Linux下用宏计算结构体中变量偏移的题目现在会不会了，真心不知道那个宏究竟是什么，然后坦然告知还是不知道。于是，又接着问fopen()和open()的区别，这个考完后回来留心看了一下，然后解释了下主要是有cache缓存的区别就过去了。</p><p>以上算是开场白的话，后面面试官一边翻阅我的简历，一边让我自我介绍一下，这就算是正式开始了。首先是问了一下项目经历，问的并不是很细，只是粗略的了解了一下。由于两个在实验室的项目因为各种原因都是不了了之结束的，所以还特意的解释了一下原因。由于自己一直是在做云计算的东西，尤其是在学校这段时间，一直都是在搞OpenStack相关的东西。所以当我介绍之前搞得一个关于OpenStack<br>Neutron的项目的时候，面试官让详细介绍一下，似乎很是感兴趣（后面事实证明他在这方面应该也在做相应的研究和开发）。我向他介绍了一下Neutron的机制，整个网络架构和数据通信关系。然后还介绍一下Neutron现有的缺陷，说是存在单点故障的问题，而且网络节点承担整个集群的网络流量存在很大的问题。于是扯到社区上刚提出来的DVR的问题，并把DVR解释了一边。结果面试官问我DVR解决的是东西向流量问题还是南北向流量问题，想了一会儿觉得是外部流量问题，所以就回答了南北向，结果被告知是东西向的。回来仔细想想，其实这个问题并不是很好回答，因为DVR的确是解决了东西向流经网络节点的流量，但也是解决部分外部网络访问的流量问题，只不过像面试官所说的，解决方案上的问题还是比较多而已。</p><p>接下来，又问了一个系统设计的问题，针对neutron上的DHCP，面试官提问如果把DHCP服务集中到单一节点上服务，应该如何设计解决，想了一下后，就说要在每个计算节点上加入一个agent来监听每个ovs网桥，并在DHCP节点使用namespace隔离dhcp-server服务，并做好相应的持久化功能。对于这个答案，面试官也没有多说。然后又问了下OVS（OpenVSwitch）上的接口有多少中类型，只回答了两种。</p><p>算法题要求用python写一个字符串逆序的函数，不能用内置的reverse函数，然后就是一个二进制数的最大匹配，就是给定大于10w个(0, 2^32)的随机不重复的数，然后给定一个整数，求与其二进制匹配最长的数。先是给了一个求模递归的解法，效率较低，然后又改进使用异或方式给了个线性复杂度的解法。</p><p>在语言方面，由于本人的C功底不行，然后就只问了python中的类继承的问题，其实就是子类寻找父类的遍历方式，当时的答案被面试官说是错的，可是回来试试之后，觉得自己当时的回答应该是没错的，汗！！！</p><p>其中还穿插一些OpenStack的一些细节问题，一时也无法一一回想描述了。感觉这次面的一般般，不知道是不是要炮灰的节奏！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/7458d655gw1f8mf6sbji1j21kw16okiv.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;国庆长假刚刚过去，早晨还是迷迷糊糊的，还没有从长假休息状态恢复过来。正当眯着眼犯困的时候，手机很不应景的震动起来。结果是一个陌生的号码，接起来后才知道对方是百度的面试官，说是要我安排时间面试一下。考虑上午已经前往实习公司了，所以和对方约定了下午2:00面试。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://xidianpanpei.github.io/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="百度" scheme="http://xidianpanpei.github.io/tags/%E7%99%BE%E5%BA%A6/"/>
    
      <category term="面试" scheme="http://xidianpanpei.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Ceilometer架构简要分析</title>
    <link href="http://xidianpanpei.github.io/2014/08/12/ceilometer-architecture-analyse/"/>
    <id>http://xidianpanpei.github.io/2014/08/12/ceilometer-architecture-analyse/</id>
    <published>2014-08-12T20:13:46.000Z</published>
    <updated>2017-11-13T11:34:53.942Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/large/7458d655gw1f70ojqz2vvj21460onjuk.jpg" alt=""></p><p>最近因为工作的需要以及论文的方向，需要了解OpenStack监控方面的知识。所以深入看了一下OpenStack的Ceilometer，大致分析了一下Ceilometer的实现机制和工作流程，因此也就形成了本文的对Ceilometer的一个大致框架介绍。</p><a id="more"></a><h2 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h2><p>Ceilometer的数据采集方式主要分为Poll和Push方式两种。</p><p>其中Push方式主要采集为OpenStack中各个组件模块中无法定时主动获取的事件消息，例如：虚拟机的创建，镜像的上传等等。该种方式的消息的采集依赖各个组件在事件发生时，依赖Ceilometer提供的消息机制将事件消息上报至消息队列当中。然后由Ceilometer-Collector中的notification-agent收集消息队列中的事件消息，然后交由指定的Pipeline将消息转换为指定的采样数据（Samples），转换之后的采样数据会被重新发送至消息队列当中，然后由Collector收集处理并存入数据库当中（MongoDB）。主要架构如下图：</p><p><img src="http://ww4.sinaimg.cn/large/7458d655gw1f70ojq34o1j20fe06aglu.jpg" alt=""></p><p>Poll方式主要采集OpenStack中的各个组件的统计数据和计算节点中的实时数据（该数据也是可以被随时统计获取的）。<br>在Controller节点上，Poll方式主要是启动相应的轮询进程（Pollsters)，依靠轮询进程定期调用组件模块的APIs获取各个组件的数据信息。然后将数据交由Pipeline进行处理，最后由Collector处理存储。此过程与上述Push方式一致。</p><p><img src="http://ww2.sinaimg.cn/large/7458d655gw1f70ojqaosmj20cp07dmxc.jpg" alt=""></p><p>在Compute节点上，Poll方式也是启动相应的轮询进程（Pollsters)，依靠轮询进程定期查询相应的信息，只是在数据采集方式上，采用虚拟机的相关驱动获取虚拟机的信息，目前主要的部署方案都是采用KVM-QEMU实现虚拟化，因此，底层信息获取上，采用的为LibVirt操纵虚拟机，同时也是通过LibVirt获取虚拟机的相关信息。当数据被采集之后，其之后的处理流程与上述两种方式都是一致的。</p><p><img src="http://ww2.sinaimg.cn/large/7458d655gw1f70ojqflv3j20ds05s74f.jpg" alt=""></p><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>前面的数据采集工作完成之后，采集来的数据会交由Pipeline进行数据处理，Pipeline主要实现的是一个数据处理链的功能。Pipeline会根据不同的配置将0个或一个或多个Transformers组装成为一条数据处理链，在这条数据处理链的末端，会被装配一个Publisher。当数据进入这条数据处理链后，会被Transformers加工处理，然后由Publisher发送至消息队列当中，由Collector收集。</p><p><img src="http://ww4.sinaimg.cn/large/7458d655gw1f70ojqg9ysj20fe04mwen.jpg" alt=""></p><p>Collector会时刻监听着消息队列，从消息队列中获取监控数据，然后将数据存入MongoDB中进行持久化。</p><p><img src="http://ww2.sinaimg.cn/large/7458d655gw1f70ojq0mrmj20bc08fglu.jpg" alt=""></p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>1.<a href="http://docs.openstack.org/developer/ceilometer/architecture.html#high-level-description" target="_blank" rel="external">OpenStack System Architecture</a><br>2.<a href="http://niusmallnan.github.io/_build/html/_templates/openstack/ceilometer_collect.html" target="_blank" rel="external">ceilometer的数据采集机制</a><br>3.<a href="http://www.cnblogs.com/alexyang8/archive/2013/02/18/2915981.html" target="_blank" rel="external">OpenStack Ceilometer简介</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/7458d655gw1f70ojqz2vvj21460onjuk.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近因为工作的需要以及论文的方向，需要了解OpenStack监控方面的知识。所以深入看了一下OpenStack的Ceilometer，大致分析了一下Ceilometer的实现机制和工作流程，因此也就形成了本文的对Ceilometer的一个大致框架介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenStack" scheme="http://xidianpanpei.github.io/categories/OpenStack/"/>
    
    
      <category term="OpenStack" scheme="http://xidianpanpei.github.io/tags/OpenStack/"/>
    
      <category term="Ceilometer" scheme="http://xidianpanpei.github.io/tags/Ceilometer/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack Neutron解析</title>
    <link href="http://xidianpanpei.github.io/2014/05/22/openstack-neutron-analyse/"/>
    <id>http://xidianpanpei.github.io/2014/05/22/openstack-neutron-analyse/</id>
    <published>2014-05-22T19:08:24.000Z</published>
    <updated>2017-11-13T11:34:53.946Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/large/7458d655gw1f8mfc0qf7cj20g405kt9d.jpg" alt=""></p><blockquote><p>很久之前写了一篇关于OpenStack Neutron解析的文章，那时只是粗略的写了一下把Neutorn的整体架构分析了一下，后来一直忙于其他事情，也就忘了去详细分析一下Neutron的架构。这次这篇算是完成未完之事，同时也是对之前的一个知识的总结及恢复。</p></blockquote><a id="more"></a><p>OpenStack的Neutron自从由nova-network从Nova中分离出来之后，一直感觉十分的不稳定，而且初期其结构也是十分的复杂。很多人刚刚接触Neutron，甚至刚刚接触OpenStack的时候，都是被困在Neutron异常复杂的机制。尤其当我们部署了一套由Neutron管理网络的OpenStack环境时，会发现很多时候都是在解决各种莫名奇妙的问题，但我们纠察问题时，总是会涉及Neutron。所以，我总是一直认为在实际的生产环境中，如果不是对于网络真的有着很特殊的需求，直接部署OpenStack的Essex版本，别人问我，我也是如是的回答。但是，我们如果是想研究OpenStack的话，Neturon的可玩性还是很大的，尤其是其支持SDN等一些很前瞻性的特性。所以，对于Neturon我们有必要深入的研究一番。</p><p>接着上次的那篇<a href="http://panpei.net.cn/2013/12/04/openstack-neutron-mechanism-introduce/" target="_blank" rel="external">文章</a>，我们再来重新回顾一下Neutron的架构，从物理上划分的话，我们的Neutron主要部署在两类节点上：Compute节点和Network节点，而至于Controller节点，那不是主要的所在，因为几乎所有的组件都要在部署一个server服务在Controller节点上。从网络分层上来看，主要分为二层网络L2-Agent，三层网络L3-Agent，以及DHCP-Agent。借用官网上几张图片，按照物理划分的方式，大致分析一下Neutron架构。</p><h2 id="Compute节点"><a href="#Compute节点" class="headerlink" title="Compute节点"></a>Compute节点</h2><p><img src="/img/2014/05/22/under-the-hood-scenario-1-linuxbridge-compute.png" alt=""></p><p>这张图摘自<a href="http://docs.openstack.org/admin-guide-cloud/content/under_the_hood_openvswitch.html#under_the_hood_openvswitch_scenario1" target="_blank" rel="external">官网</a>，为Compute节点的网络架构及流程分析图。这张图中，我们可以清楚的看到网络相关的一些设备（其实就是一些进程或者系统接口）被分为四类：<code>TAP device</code>，<code>veth pair</code>，<code>Linux Bridge</code>，<code>Open vSwitch</code>，这里其实用的Open vSwitch的方式部署Neutron，而我之前也一直使用Open vSwitch部署的，但是这里却也是有着Linux Bridge的，正如之前<a href="http://panpei.net.cn/2013/12/04/openstack-neutron-mechanism-introduce/" target="_blank" rel="external">文章</a>所言，这个是为了实现安全组功能，但Open vSwitch暂不支持OpenStack的实现方式，所以只好用Linux Bridge实现qbr网桥作为一个折衷方案。接下来就是最为大头的Open vSwitch，它在Neutron中构建了一个虚拟的交换机，而这个虚拟交换机由L2-Agent控制着，最终所有Compute节点中的虚拟交换机统一构成一个巨大的虚拟交换机，统一控制虚拟机在二层网络的数据交换和接入功能。从图中我们可以看出每个Compute节点有两个Open vSwitch网桥，其实<code>br-int</code>才是真正扮演交换机角色的，而<code>br-eth1</code>则是通过<code>GRE</code>通道在所有节点之间构成一个统一的通信层，实现各个Compute节点上虚拟机之间的通信。</p><h2 id="Network节点"><a href="#Network节点" class="headerlink" title="Network节点"></a>Network节点</h2><p>接下来就是看看Network节点上的情况，下面的是Network节点的原理图：</p><p><img src="/img/2014/05/22/under-the-hood-scenario-2-ovs-network.png" alt=""></p><p>这张图上，我们可以清楚看到Network节点被分为三大部分：<code>Configured by L2-Agent</code>，<code>Configured by L3-Agent</code>，<code>Configured by DHCP-Agent</code>，而L2-Agent那部分和我们在Compute节点讨论的是一致的，所以此处就忽略了。接着我们看L3-Agent，在Neutron中，出现了私有网络这一概念，当然也是实际存在的。而依据以前的nova-network，是无法实现这一功能的，nova-network顶多能使用VLAN技术实现网络隔离，而无法实现真正的私有网络。在物理网络中，我们要想实现一个私有网络，那么就必须有个路由器才行，而L3-Agent正是Neutron中实现这个路由器而存在的（事实上，我们在Havana版本中部署的环境中，网络拓扑图中就很形象的显示了这些routers），L3-Agent的底层实现采用的是Linux系统自带的iptables技术，通过动态的生成配置iptables规则，实现网络的路由功能以及floatip功能。而每个用户都要一个私有网络的话，一个路由肯定是不够用的，接着就是Linux中namespace技术的用武之地了，事实上，Neutron为每个私有网络都配置一个router和dnsmasq，而这个就是依靠namespace进行规则和配置的隔离。如下图所示：</p><p><img src="/img/2014/05/22/under-the-hood-scenario-2-ovs-netns.png" alt=""></p><p>现在，每个私有网络可以建立了，但是我们总不能为每个虚拟机手动配置私有ip的，所以这时候DHCP-Agent就显示了其用处，DHCP-Agent通过控制dnsmasq实现了DHCP功能，这样每个虚拟机在启动的时候就可以动态获取私有ip了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，我们就已经把OpenStack Neutron的整理结构分析清楚了，剩下就是我的上篇<a href="http://panpei.net.cn/2013/12/04/openstack-neutron-mechanism-introduce/" target="_blank" rel="external">文章</a>中的流程打通了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://openstack.redhat.com/Networking_in_too_much_detail" target="_blank" rel="external">Networking in too much detail</a></li><li><a href="http://docs.openstack.org/admin-guide-cloud/content/under_the_hood_openvswitch.html#under_the_hood_openvswitch_scenario1" target="_blank" rel="external">OpenStack Cloud Administrator Guide</a></li><li><a href="http://www.ibm.com/developerworks/cn/cloud/library/1402_chenhy_openstacknetwork/" target="_blank" rel="external">OpenStack 网络：Neutron 初探</a></li><li><a href="http://blog.csdn.net/lynn_kong/article/details/13503847" target="_blank" rel="external">Neutron中的iptables</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/7458d655gw1f8mfc0qf7cj20g405kt9d.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;很久之前写了一篇关于OpenStack Neutron解析的文章，那时只是粗略的写了一下把Neutorn的整体架构分析了一下，后来一直忙于其他事情，也就忘了去详细分析一下Neutron的架构。这次这篇算是完成未完之事，同时也是对之前的一个知识的总结及恢复。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="OpenStack" scheme="http://xidianpanpei.github.io/categories/OpenStack/"/>
    
    
      <category term="OpenStack" scheme="http://xidianpanpei.github.io/tags/OpenStack/"/>
    
      <category term="Neutron" scheme="http://xidianpanpei.github.io/tags/Neutron/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之工厂模式</title>
    <link href="http://xidianpanpei.github.io/2014/03/28/design-patterns-factory-mode/"/>
    <id>http://xidianpanpei.github.io/2014/03/28/design-patterns-factory-mode/</id>
    <published>2014-03-28T20:01:44.000Z</published>
    <updated>2017-11-13T11:34:53.942Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/7458d655gw1f8mfgto8hpj20rs0jn445.jpg" alt=""></p><p>个人而言，由于写的代码并不是很多，因而对于很多的设计模式，实际上大多都只是停留在纸面的理解上。但是设计模式中的很多思想，还是很是值得我们去好好去理解研读的，所以很多设计模式还是要去熟悉一下的。</p><a id="more"></a><p>今天被问到工厂模式与new的区别，脑袋就那么断线了，有<code>工厂模式</code>这个概念，却把它的一些特性给忘了。充分暴露了学习不够深入，理解不够透彻的弊病了。所以就从工厂模式开始，慢慢复习一下设计模式吧。</p><p>先来回答上面那个问题吧，工厂模式往简单了说，其实就是把new一个对象的操作做了一些封装，往复杂的方向来说，则不仅仅是对new进行了封装，而且还将具体的实例化过程推迟到了具体的工厂子类中。</p><p>我们先从<code>简单工厂</code>开始，图个方便，就以《Head First设计模式》上的Pizza例子解释吧。</p><p>好了，现在我们有一家Pizza店<code>PizzaStore</code>，所有的Pizza都是<code>PizzaStore</code>自己生产的，每当有一种新的口味流行时，我们就要在这个类中间增加一种Pizza制作方法。当我们的店面还只是一个的时候，这样的方式还是可以接受的。很快，我们的Pizza店由于广受欢迎，在这个A城市开了很多分店。然后，问题就出来，每次新的Pizza出来时，我们都要对每个店面进行修改，这样的弊病会随着店面数量的增加而不断加重。于是，我们对其结构进行一次改造，我们把Pizza的生产任务交给一个独立的工厂<code>SimplePizzaFactory</code>，然后各个店面都从这个工厂中获取各种Pizza。这样，当每次出现新的Pizza的时候，我们就只需要更改一下<code>SimplePizzaFactory</code>就行了。</p><p><img src="/img/2014/03/28/simplefactory.png" alt=""></p><p>我们可以把这个叫做<code>简单工厂模式</code>，但事实上，<code>简单工厂模式</code>算不得设计模式，只能说是个良好的设计习惯吧，上图就为我们展示了<code>简单工厂模式</code>的类图结构。</p><p>过了好长时间，我们的Pizza店实在是太受欢迎了。于是乎我们开始在其他城市开设分店，可是问题也随之而来，我们发现其他城市的人们的口味对于同一种Pizza也是有所不同的，而我们原来的工厂只能统一生产同一口味的Pizza。于是，我们又把生产Pizza的权利转给Pizza店，让他们自己决定如何生产Pizza，而我们只需要提供一个统一的店面形象就行了，就像类图中描述的一样，而这个模式就是<code>工厂模式</code>了。</p><p><img src="/img/2014/03/28/factory.png" alt=""></p><p>OK！问题似乎解决了！可是，我们最初遇到的品种增多的问题似乎又回来了。每当新种类出来，每家店面又都忙着添加新Pizza，这看起来好麻烦啊！身为爱偷懒的程序猿，怎么能容忍这么麻烦的事出现。于是，我们又改造了我们的Pizza店。</p><p>这次，我们决定还是把Pizza生产的权利收回来。在前面<code>简单工厂模式</code>的基础上，我们进一步改造，决定在每个城市建立一座Pizza工厂，当然，每个工厂由当地的城市去兴建，而我们只需要提供一个工厂的统一建设标准，至于每家工厂自己如何生产Pizza，我们就不再去关心了，而且，此后这个城市的Pizza分店都是从各自城市的Pizza工厂获取Pizza的，这既保证了Pizza的质量和品味，有保证了新产品增加的灵活性。其实，这个模式就是<code>工厂模式</code>的一个升级了，我们称之为<code>抽象工厂模式</code>，顾名思义，我们这次把工厂也给抽象化了。<code>抽象工厂模式</code>的类图如下所示。</p><p><img src="/img/2014/03/28/abstractfactory.png" alt=""></p><p>通过这个Pizza店面的例子，差不多已经把<code>工厂模式</code>和<code>抽象工厂模式</code>的主要思想已经讲解清楚了，至于具体实现的代码，可以参考《Head First设计模式》一书中的工厂模式章节。</p><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><ul><li>《Head First设计模式》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/7458d655gw1f8mfgto8hpj20rs0jn445.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;个人而言，由于写的代码并不是很多，因而对于很多的设计模式，实际上大多都只是停留在纸面的理解上。但是设计模式中的很多思想，还是很是值得我们去好好去理解研读的，所以很多设计模式还是要去熟悉一下的。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://xidianpanpei.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://xidianpanpei.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="工厂模式" scheme="http://xidianpanpei.github.io/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="抽象工厂模式" scheme="http://xidianpanpei.github.io/tags/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack Havana Ceilometer安装指导</title>
    <link href="http://xidianpanpei.github.io/2014/03/08/ceilometer-deploy-guide/"/>
    <id>http://xidianpanpei.github.io/2014/03/08/ceilometer-deploy-guide/</id>
    <published>2014-03-08T15:44:07.000Z</published>
    <updated>2017-11-13T11:34:53.942Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/7458d655gw1f70ojqmn8mj20dw0aft8t.jpg" alt=""></p><h2 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h2><p>由于我们的系统在很早之前就部署完成了。当时Ceilomter刚刚在Havana版本中发布，我们主要专注于网络和虚拟化部分，所以当时就没有在我们的Havana版本环境中安装Ceilomter，但是现在由于需要，开始研究OpenStack的监控功能， 所以就需要在我们现有的系统上补上Ceilomter了。利用了网上的各种教程，但是发现都有些问题，最终不得不依靠官方的Havana部署教程，利用其Ceilometer安装那一节的教程，完成了Ceilometer的完美部署。</p><a id="more"></a><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p>我们的系统是依据OpenStack Havana版本部署的，整个系统采用网络集中式部署，也就是说我们的系统分为三个部分：控制节点，网络节点和计算节点。具体的系统相关信息可以参照该篇<a href="https://github.com/xidianpanpei/OpenStack-Havana-Install-Guide-CN-OVS_MutliNode" target="_blank" rel="external">教程</a>。</p><h3 id="所有节点"><a href="#所有节点" class="headerlink" title="所有节点"></a>所有节点</h3><p>我们需要在所有的节点安装以下的安装包，这个是Ceilometer的实现基础：</p><pre><code>sudo apt-get install python-ceilometer  ceilometer-common</code></pre><h3 id="控制节点"><a href="#控制节点" class="headerlink" title="控制节点"></a>控制节点</h3><p>1.在控制节点安装以下的包：</p><pre><code>sudo apt-get install ceilometer-api ceilometer-collector ceilometer-agent-central python-ceilometerclient</code></pre><p>2.如此之后，控制节点上就已经完成了Ceilometer大部分安装了，接下来就是安装mogodb数据库，这个是Ceilometer默认的数据存储的仓库：</p><pre><code>sudo apt-get install mongodb</code></pre><p>3.接着我们开始配置mongodb监听所有的网络接口请求：</p><pre><code>sudo sed -i &apos;s/127.0.0.1/0.0.0.0/g&apos; /etc/mongodb.conf</code></pre><p>4.重启mongodb服务，让配置生效：</p><pre><code>service mongodb restart</code></pre><p>5.创建数据库ceilometer和对应的用户：</p><p>首先进入mongodb：</p><pre><code>mongo</code></pre><p>接着执行创建用户命令：</p><pre><code>&gt;use ceilometer    &gt;db.addUser( { user: &quot;ceilometer&quot;, pwd: &quot;CEILOMETER_DBPASS&quot;, roles: [ &quot;readWrite&quot;, &quot;dbAdmin&quot; ]} )</code></pre><p>6.编辑/etc/ceilometer/ceilometer.conf文件，配置数据库参数：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[database]</span></span><br><span class="line"><span class="comment"># The SQLAlchemy connection string used to connect to the</span></span><br><span class="line"><span class="comment"># database (string value)</span></span><br><span class="line"><span class="attr">connection</span> = mongodb://ceilometer:CEILOMETER_DBPASS@controller:<span class="number">27017</span>/ceilometer</span><br></pre></td></tr></table></figure></p><p>7.利用openssl生成一个随机token密钥，该密钥用于Ceilometer各个组件之间通信加密使用：</p><pre><code>openssl rand -hex 10    cefafd2288d0e4e43005 （注：这是命令生成的随机token）</code></pre><p>编辑/etc/ceilometer/ceilometer.conf文件，修改中间的 <code>[publisher_rpc]</code> 选项，配置<code>token</code>：<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[publisher_rpc]</span><br><span class="line"># <span class="type">Secret</span> <span class="keyword">value</span> <span class="keyword">for</span> signing metering messages (<span class="built_in">string</span> <span class="keyword">value</span>)</span><br><span class="line">metering_secret = cefafd2288d0e4e43005</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>8.编辑/etc/ceilometer/ceilometer.conf，修改<code>RabbitMQ</code>配置选项：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rabbit_host</span> = controller_ip_address（自行修改）</span><br></pre></td></tr></table></figure></p><p>9.编辑/etc/ceilometer/ceilometer.conf，修改日志打印目录：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[DEFAULT]</span></span><br><span class="line"><span class="attr">log_dir</span> = /var/log/ceilometer</span><br></pre></td></tr></table></figure></p><p>10.Keystone相关信息创建：</p><pre><code>keystone user-create --name=ceilometer --pass=CEILOMETER_PASS --email=ceilometer@example.com    keystone user-role-add --user=ceilometer --tenant=service --role=admin        keystone service-create --name=ceilometer --type=metering --description=&quot;Ceilometer Telemetry Service&quot;        keystone endpoint-create --service-id=the_service_id_above --publicurl=http://controller_ip_address:8777 --internalurl=http://controller_ip_address:8777 --adminurl=http://controller_ip_address:8777</code></pre><p>11.编辑/etc/ceilometer/ceilometer.conf，修改相关配置：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[keystone_authtoken]</span></span><br><span class="line"><span class="attr">auth_host</span> = controller_ip_address</span><br><span class="line"><span class="attr">auth_port</span> = <span class="number">35357</span></span><br><span class="line"><span class="attr">auth_protocol</span> = http</span><br><span class="line"><span class="attr">auth_uri</span> = http://controller_ip_address:<span class="number">5000</span></span><br><span class="line"><span class="attr">admin_tenant_name</span> = service</span><br><span class="line"><span class="attr">admin_user</span> = ceilometer</span><br><span class="line"><span class="attr">admin_password</span> = CEILOMETER_PASS</span><br><span class="line"></span><br><span class="line"><span class="section">[service_credentials]</span></span><br><span class="line"><span class="attr">os_username</span> = ceilometer</span><br><span class="line"><span class="attr">os_tenant_name</span> = service</span><br><span class="line"><span class="attr">os_password</span> = CEILOMETER_PASS</span><br></pre></td></tr></table></figure></p><p>12.重启Ceilometer相关服务，使其生效：</p><pre><code>service ceilometer-agent-central restart    service ceilometer-api restart    service ceilometer-collector restart</code></pre><p>13.编辑/etc/glance/glance-api.conf，修改<code>Glance</code>配置：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">notifier_strategy</span> = rabbit</span><br><span class="line"><span class="attr">rabbit_host</span> = controller</span><br></pre></td></tr></table></figure></p><p>重启相关服务：</p><pre><code>service glance-registry restart        service glance-api restart</code></pre><p>14.编辑/etc/cinder/cinder.conf，修改<code>Cinder</code>配置：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">control_exchange = cinder</span><br><span class="line">notification_driver = cinder<span class="selector-class">.openstack</span><span class="selector-class">.common</span><span class="selector-class">.notifier</span><span class="selector-class">.rpc_notifier</span></span><br></pre></td></tr></table></figure></p><p>重启相关服务：</p><pre><code>service cinder-volume restart    service cinder-api restart</code></pre><p>注：由于我们的环境中没有安装Swift，所以有关Swift配置的部分就省略了。需要的话，请查看本教程中的参考资料。</p><h3 id="计算节点"><a href="#计算节点" class="headerlink" title="计算节点"></a>计算节点</h3><p>1.安装计算节点所需服务：</p><pre><code>sudo apt-get install ceilometer-agent-compute</code></pre><p>2.编辑 /etc/nova/nova.conf文件，配置Nova相关选项：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[DEFAULT]</span><br><span class="line">...</span><br><span class="line">instance_usage_audit = True</span><br><span class="line">instance_usage_audit_period = hour</span><br><span class="line">notify_on_state_change = vm_and_task_state</span><br><span class="line">notification_driver = nova.openstack.common.notifier.rpc_notifier</span><br><span class="line">notification_driver = ceilometer.compute.nova_notifier</span><br></pre></td></tr></table></figure></p><p>3.编辑/etc/ceilometer/ceilometer.conf，配置计算节点上Ceilometer的选项：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[publisher_rpc]</span></span><br><span class="line"><span class="comment"># Secret value for signing metering messages (string value)</span></span><br><span class="line"><span class="attr">metering_secret</span> = cefafd2288d0e4e43005</span><br><span class="line"></span><br><span class="line"><span class="section">[DEFAULT]</span></span><br><span class="line"><span class="attr">rabbit_host</span> = controller</span><br><span class="line"></span><br><span class="line"><span class="section">[keystone_authtoken]</span></span><br><span class="line"><span class="attr">auth_host</span> = controller_ip_address</span><br><span class="line"><span class="attr">auth_port</span> = <span class="number">35357</span></span><br><span class="line"><span class="attr">auth_protocol</span> = http</span><br><span class="line"><span class="attr">admin_tenant_name</span> = service</span><br><span class="line"><span class="attr">admin_user</span> = ceilometer</span><br><span class="line"><span class="attr">admin_password</span> = CEILOMETER_PASS</span><br><span class="line"></span><br><span class="line"><span class="section">[service_credentials]</span></span><br><span class="line"><span class="attr">os_auth_url</span> = http://controller_ip_address:<span class="number">5000</span>/v2.<span class="number">0</span></span><br><span class="line"><span class="attr">os_username</span> = ceilometer</span><br><span class="line"><span class="attr">os_tenant_name</span> = service</span><br><span class="line"><span class="attr">os_password</span> = CEILOMETER_PASS</span><br><span class="line"></span><br><span class="line"><span class="section">[DEFAULT]</span></span><br><span class="line"><span class="attr">log_dir</span> = /var/log/ceilometer</span><br></pre></td></tr></table></figure></p><p>4.重启服务使得配置生效：</p><pre><code>service ceilometer-agent-compute restart</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>1.<a href="http://docs.openstack.org/havana/install-guide/install/apt/content/ceilometer-install.html" target="_blank" rel="external">Install the Telemetry module - OpenStack Installation Guide for Ubuntu 12.04 (LTS)  - havana</a><br>2.<a href="http://www.cnblogs.com/awy-blog/p/3447176.html" target="_blank" rel="external">Ubuntu 12.04 Server OpenStack Havana多节点(OVS+GRE)安装</a><br>3.<a href="http://yansu.org/2013/10/01/deploy-ceilometer-of-openstack.html" target="_blank" rel="external">部署Ceilometer到已有环境中</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/7458d655gw1f70ojqmn8mj20dw0aft8t.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;题记&quot;&gt;&lt;a href=&quot;#题记&quot; class=&quot;headerlink&quot; title=&quot;题记&quot;&gt;&lt;/a&gt;题记&lt;/h2&gt;&lt;p&gt;由于我们的系统在很早之前就部署完成了。当时Ceilomter刚刚在Havana版本中发布，我们主要专注于网络和虚拟化部分，所以当时就没有在我们的Havana版本环境中安装Ceilomter，但是现在由于需要，开始研究OpenStack的监控功能， 所以就需要在我们现有的系统上补上Ceilomter了。利用了网上的各种教程，但是发现都有些问题，最终不得不依靠官方的Havana部署教程，利用其Ceilometer安装那一节的教程，完成了Ceilometer的完美部署。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenStack" scheme="http://xidianpanpei.github.io/categories/OpenStack/"/>
    
    
      <category term="OpenStack" scheme="http://xidianpanpei.github.io/tags/OpenStack/"/>
    
      <category term="Ceilometer" scheme="http://xidianpanpei.github.io/tags/Ceilometer/"/>
    
  </entry>
  
  <entry>
    <title>指针的一点理解</title>
    <link href="http://xidianpanpei.github.io/2014/03/04/some-interesting-things-about-points/"/>
    <id>http://xidianpanpei.github.io/2014/03/04/some-interesting-things-about-points/</id>
    <published>2014-03-04T11:27:06.000Z</published>
    <updated>2017-11-13T11:34:53.946Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/large/7458d655gw1f8mfmzm62oj20m80m8t9q.jpg" alt=""></p><p>每天打开电脑的第一件事就是开QQ、开微博（躺枪的举个手），然后就是打开自己的InoReader（前几天还是Digg Reader，但是嫌弃界面太简洁和功能太简单了，就换了）。每天都能看到不同的有趣的文章其实也是中享受的。</p><a id="more"></a><p>今天就在「伯乐在线」上看到一篇<a href="http://blog.jobbole.com/60647/" target="_blank" rel="external">文章</a>，其实算不上文章的，只是把StackOverFlow上面的一个问题给翻译了，但是内容本身还是值得探讨的。这个问题就是讨论指针的，没错，就是C/C++的指针的，估计很多人认为很简单了。但是说实话，我到现在还是不敢说自己已经完全了解指针的，当然也没有把指针玩的很溜的。</p><p>关于指针我记得有个经典的段子，形象的说明指针的优势和缺陷的，可惜已经记不太清楚了。个人认为，编程语言无非就是为我们提供一套操作内存与CPU的规则，而我们写出来的程序，就是我们利用这套规则编写的流程指导书而已。基于这种想法的话，我们会发现C语言提供的指针，真的是个非常美妙的工具。因为指针的存在，我们对于内存的操作，可以达到前所未有的灵活多变。当然，就像玩双节棍一样，在高手手中，是威力无穷的武器，但是到了低手手中，说不定就是自伤八百的凶器了。而低手就是要在这种近乎自残的锻炼方式中，才能慢慢成为高手。</p><p>记得当初学C语言的时候（相信大家都一样，大学学的第一门语言都是C语言），由于课时紧张，指针这个最重要的部分，直接就被授课老师给略掉了，所以后来一直对此耿耿于怀，因为自己走了好多弯路，才明白编程的意义所在。指针真的很重要，我认为只要我们真的理解指针的意义，对于编程来说，我们已经了解了一半了。然而，等我把指针弄懂了，其实指针本身也不难，但是却是难在如何使用上，对于指针的使用，其实就是我们对于内存的操作过程。当我们把指针调用来调用去的时候，很容易就把自己给绕晕了，最后连自己都不知道某个到底指到哪块内存了。所以，个人认为，使用指针最重要的原则就是，自己一定要有清晰的思路，能够明晰知道自己操作的指针的具体指向，否则就别用了吧。</p><p>说了这么多，很多其实都是废话了。其实，C中的指针对于我们来说，最终要的就是记住两个符号：*和&amp;，这两个符号会一路伴随着我们的指针使用历程的。*表示取值，而&amp;则表示取址，谨记它们的含义，那么我们的指针历程也就不会那么艰辛了。</p><p>关于单重指针，我们假设有以下的范例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;i;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"i's address is: %lx\n"</span>, &amp;i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"p's value is: %lx\n"</span>, p);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"*p's value is: %d\n"</span>, *p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们简单编译执行后，就有了以下的结果：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i<span class="symbol">'s</span> address <span class="keyword">is</span>: bfd42908  </span><br><span class="line">p<span class="symbol">'s</span> value <span class="keyword">is</span>: bfd42908</span><br><span class="line">*p<span class="symbol">'s</span> values <span class="keyword">is</span>: <span class="number">5</span></span><br></pre></td></tr></table></figure><p>很明显啦，p就是指向i所在内存的一个指针，其实就是i的别名。回过头来我们在来看看*，其实*就是说明指针的符号，它表示p是一个指针变量，如果是两个**则是表示指针的指针，然后我们可以依次类推一下了。</p><p>我们再来看看二重指针，也就是那篇文章中讨论的问题。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *ip1 = &amp;i;</span><br><span class="line"><span class="keyword">int</span> *ip2 = &amp;j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">printf</span>(<span class="string">"i's address is: %lx\n"</span>, &amp;i);</span><br><span class="line"><span class="keyword">printf</span>(<span class="string">"j's address is: %lx\n"</span>, &amp;j);</span><br><span class="line"></span><br><span class="line"><span class="keyword">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">printf</span>(<span class="string">"ip1 points to: %lx\n"</span>, ip1);</span><br><span class="line"><span class="keyword">printf</span>(<span class="string">"ip2 points to: %lx\n"</span>, ip2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">printf</span>(<span class="string">"ip1's address is: %lx\n"</span>, &amp;ip1);</span><br><span class="line"><span class="keyword">printf</span>(<span class="string">"ip2's address is: %lx\n"</span>, &amp;ip2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> **ipp = &amp;ip1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">printf</span>(<span class="string">"ipp points to: %lx\n"</span>, ipp);</span><br><span class="line"><span class="keyword">printf</span>(<span class="string">"ipp's address is: %lx\n"</span>, &amp;ipp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">printf</span>(<span class="string">"---------------------\n"</span>);</span><br><span class="line"></span><br><span class="line">*ipp = ip2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">printf</span>(<span class="string">"ip1 points to: %lx\n"</span>, ip1);</span><br><span class="line"><span class="keyword">printf</span>(<span class="string">"ip1's address is: %lx\n"</span>, &amp;ip1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">printf</span>(<span class="string">"ipp points to: %lx\n"</span>, ipp);</span><br><span class="line"><span class="keyword">printf</span>(<span class="string">"ipp's address is: %lx\n"</span>, &amp;ipp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">printf</span>(<span class="string">"*ipp's value is: %lx\n"</span>, *ipp);</span><br><span class="line"><span class="keyword">printf</span>(<span class="string">"**ipp's value is: %lx\n"</span>, **ipp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码执行完成后，我们会有以下的结果：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">i<span class="symbol">'s</span> address <span class="keyword">is</span>: <span class="number">22</span>ff1c  </span><br><span class="line">j<span class="symbol">'s</span> address <span class="keyword">is</span>: <span class="number">22</span>ff18</span><br><span class="line"></span><br><span class="line">ip1 points <span class="keyword">to</span>: <span class="number">22</span>ff1c</span><br><span class="line">ip2 points <span class="keyword">to</span>: <span class="number">22</span>ff18</span><br><span class="line"></span><br><span class="line">ip1<span class="symbol">'s</span> address <span class="keyword">is</span>: <span class="number">22</span>ff14</span><br><span class="line">ip2<span class="symbol">'s</span> address <span class="keyword">is</span>: <span class="number">22</span>ff10</span><br><span class="line"></span><br><span class="line">ipp points <span class="keyword">to</span>: <span class="number">22</span>ff14</span><br><span class="line">ipp<span class="symbol">'s</span> address <span class="keyword">is</span>: <span class="number">22</span>ff0c</span><br><span class="line"></span><br><span class="line">*ipp<span class="symbol">'s</span> value <span class="keyword">is</span>: <span class="number">22</span>ff1c  </span><br><span class="line">**ipp<span class="symbol">'s</span> value <span class="keyword">is</span>: <span class="number">5</span></span><br><span class="line">++++++++++++++++++++++++++ </span><br><span class="line">ip1 points <span class="keyword">to</span>: <span class="number">22</span>ff18  </span><br><span class="line">ip1<span class="symbol">'s</span> address <span class="keyword">is</span>: <span class="number">22</span>ff14  </span><br><span class="line"></span><br><span class="line">ipp points <span class="keyword">to</span>: <span class="number">22</span>ff14  </span><br><span class="line">ipp<span class="symbol">'s</span> address <span class="keyword">is</span>: <span class="number">22</span>ff0c  </span><br><span class="line"></span><br><span class="line">*ipp<span class="symbol">'s</span> value <span class="keyword">is</span>: <span class="number">22</span>ff18  </span><br><span class="line">**ipp<span class="symbol">'s</span> value <span class="keyword">is</span>: <span class="number">6</span></span><br></pre></td></tr></table></figure><p>从上面的结果我们可以看到，**ipp是一个二重指针，它实际上是指向了一重指针*ip1的内存地址。也就是说ipp实际上指向指针ip1的指针。</p><p>没改变之前的最后的两行可以看到，**ipp的值为5，也就说，ipp最终指向的还是变量i，而*ipp也是存着ip1的地址值得，也就说ipp还是指向ip1的，而*ipp实际上指针ip1的别名罢了。</p><p>OK，接下来我们来改变一次：<code>*ipp = ip2;</code>，可以发现ip1指向了j，而且*ipp和**ipp也都随着ip1的变化而变化了，这也再次证明了我们关于*ipp的说明：*ipp是ip1的别名。下面我们可以看看更为直观的图示：</p><p><img src="/img/2014/03/04/a.gif" alt=""></p><p><img src="/img/2014/03/04/b.gif" alt=""></p><p>因此，我们可以知晓多重指针中的*的作用，当某个指针**ipp的*被去除了一个再次操作（*ipp），其实就是对**ipp指向的那个内存中的数据进行操作，而*ipp也其实就是这块内存的另一个别名罢了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/7458d655gw1f8mfmzm62oj20m80m8t9q.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;每天打开电脑的第一件事就是开QQ、开微博（躺枪的举个手），然后就是打开自己的InoReader（前几天还是Digg Reader，但是嫌弃界面太简洁和功能太简单了，就换了）。每天都能看到不同的有趣的文章其实也是中享受的。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="http://xidianpanpei.github.io/categories/C-C/"/>
    
    
      <category term="C语言" scheme="http://xidianpanpei.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="指针" scheme="http://xidianpanpei.github.io/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu密码重置无效错误</title>
    <link href="http://xidianpanpei.github.io/2014/02/26/ubuntu-password-reset-error/"/>
    <id>http://xidianpanpei.github.io/2014/02/26/ubuntu-password-reset-error/</id>
    <published>2014-02-26T23:09:52.000Z</published>
    <updated>2017-11-13T11:34:53.946Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/img/2014/02/26/ubuntu.png" alt=""></p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>今天，实验室的一同学在登录自己的Ubuntu系统时，发现自己忘了登录密码。于是重启进入<code>恢复模式</code>中，想要重置用户密码，结果执行相关命令后，得到以下错误提示：</p><a id="more"></a><pre><code>root@username-PC:~# passwd usernameEnter new UNIX password:Retype new UNIX password:passwd: Authentication token manipulation errorpasswd: password unchanged</code></pre><p>我刚开始以为是同我上次的系统循环登录的原因是类似的，于是按照我的<a href="http://panpei.net.cn/2014/02/20/fixed-elementaryos-login-bug/" target="_blank" rel="external">教程</a>操作，修改了相关文件的权限，重新在<code>恢复模式</code>下重置密码，结果还是同样的错误。在伟大的Google的帮助下，找到了解决问题的办法，原因似乎是磁盘的根目录挂载出现了问题，执行以下命令：</p><pre><code>mount -rw -o remount /</code></pre><p>然后在<code>恢复模式</code>中就可以重置密码了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《Authentication token manipulation error》:<a href="http://askubuntu.com/questions/91188/authentication-token-manipulation-error" target="_blank" rel="external">http://askubuntu.com/questions/91188/authentication-token-manipulation-error</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/img/2014/02/26/ubuntu.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;今天，实验室的一同学在登录自己的Ubuntu系统时，发现自己忘了登录密码。于是重启进入&lt;code&gt;恢复模式&lt;/code&gt;中，想要重置用户密码，结果执行相关命令后，得到以下错误提示：&lt;/p&gt;
    
    </summary>
    
      <category term="杂项" scheme="http://xidianpanpei.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="Ubuntu" scheme="http://xidianpanpei.github.io/tags/Ubuntu/"/>
    
      <category term="密码" scheme="http://xidianpanpei.github.io/tags/%E5%AF%86%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Elementary OS循环登录问题</title>
    <link href="http://xidianpanpei.github.io/2014/02/20/fixed-elementaryos-login-bug/"/>
    <id>http://xidianpanpei.github.io/2014/02/20/fixed-elementaryos-login-bug/</id>
    <published>2014-02-20T10:28:45.000Z</published>
    <updated>2017-11-13T11:34:53.942Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/mw690/7458d655ly1flalipfo9ej20zk0m8q65.jpg" alt=""></p><p><a href="http://elementaryos.org/" target="_blank" rel="external">Elementary OS</a>自从出来之后，便声称是“最美的Linux”。我在很早之前看了相关介绍后，出于对于Elementary OS简洁精致的界面的喜爱，便很快安装了Luna版本的，这也是目前唯一的一个正式版本。</p><a id="more"></a><p>由于一直把安装了Elementary OS的电脑当作服务器使用，便一直没有关机（实验室的电脑，因此才可以不关机啊）。等到寒假放假回家，实验室要求断电，这才把电脑关机。可是关机的总是在界面无法关机，当时也没有太注意，直接就给强行关机了。等到前两天回到实验室，再次开机时，才发现已经无法通过图形界面登录进去了，也就是tty7无法登录。通过Google的帮助，弄了小半天，搞定了界面登录问题。（其实主要是Elementary OS太过于小众，没有多少资料，不过由于其是基于Ubuntu的，可以使用一部分Ubuntu的资料）</p><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>开机进入图形登录界面后，输入密码后系统开始确认，先是黑屏几秒，然后就直接跳回到登录界面，一直无法进入桌面。但是，使用<code>Ctrl</code>+<code>Alt</code>+<code>F1</code>，可以进入tty1，通过命令行登录进去。</p><h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>1.使用<code>Ctrl</code>+<code>Alt</code>+<code>F1</code>，使用命令行界面登录系统。<br>2.执行命令<code>sudo su</code>，切换至<code>root</code>权限。<br>3.执行命令<code>ls -lah</code>，可以看到：</p><pre><code>-rw-------  1 root root   53 Nov 29 10:19 .Xauthority</code></pre><p>4.执行命令<code>chown username:username .Xauthority</code>，修改文件的用户和用户组，然后重启系统，就可以正常登录了。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《Ubuntu gets stuck in a Login Loop》:<a href="http://askubuntu.com/questions/223501/ubuntu-gets-stuck-in-a-login-loop" target="_blank" rel="external">http://askubuntu.com/questions/223501/ubuntu-gets-stuck-in-a-login-loop</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/7458d655ly1flalipfo9ej20zk0m8q65.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://elementaryos.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Elementary OS&lt;/a&gt;自从出来之后，便声称是“最美的Linux”。我在很早之前看了相关介绍后，出于对于Elementary OS简洁精致的界面的喜爱，便很快安装了Luna版本的，这也是目前唯一的一个正式版本。&lt;/p&gt;
    
    </summary>
    
      <category term="杂项" scheme="http://xidianpanpei.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="ElementaryOS" scheme="http://xidianpanpei.github.io/tags/ElementaryOS/"/>
    
      <category term="登录" scheme="http://xidianpanpei.github.io/tags/%E7%99%BB%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>如何写好一篇论文</title>
    <link href="http://xidianpanpei.github.io/2014/02/02/how-to-write-a-paper/"/>
    <id>http://xidianpanpei.github.io/2014/02/02/how-to-write-a-paper/</id>
    <published>2014-02-02T16:13:34.000Z</published>
    <updated>2017-11-13T11:34:53.942Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/mw690/7458d655ly1flalbaelhvj20sg0kf7wh.jpg" alt=""></p><p>其实身为一名将来要成为码农的软工master，学术活动基本上是与我们无关的，而与写paper也几乎是绝缘的。然而因为读书报告的缘故，也是寥寥看了几篇paper，尤其是Google的那三篇牛文，更是好好的拜读了一番。读完之后，除了对<code>GFS</code>、<code>MapReduce</code>、<code>BigTable</code>有了些了解外，倒是对这些paper的行文风格甚是感兴趣，觉得这些paper的行文似乎都是一脉相承，但是其思路倒是很是清晰明了。</p><a id="more"></a><p>今天闲来无事，把之前从网络上淘来一份<a href="http://crazlyli0n.qiniudn.com/writing_a_paper_slides.pdf" target="_blank" rel="external">slide</a>给看了，主题就是讨论如何写好一篇论文的。至此想起之前的那些牛文，顿时明白了那些行文风格是从何处而来的了。于是，也有了把这个slide写成blog的想法。</p><p>这篇文章主要是把slide中的我认为比较重要的部分提取出来予以整合以实现共享吧。</p><p>首先，我们明确一下写paper的目的，按照国内这种功利的学术氛围，paper无非是用来实现各种利益的工具而已。然而，paper的真正的目的应该是交流思想的，把我们的对于某一问题的思想传递给别人。正如slide中的作者所述：</p><blockquote><p>The greatest ideas are (literally) worthless if<br>you keep them to yourself.</p></blockquote><p>对于写paper的方式，原作者给出了两种方式：<br>1.<code>Idea</code> -&gt; <code>Do Research</code> -&gt; <code>Write Paper</code><br>2.<code>Idea</code> -&gt; <code>Write Paper</code> -&gt; <code>Do Research</code><br>而且，原作者似乎比较倾向于第二种方式，理由无外乎借助外部力量实现研究的明确性。但是，由于我没有写过paper的经历，总是觉得的第一种方式才是合乎逻辑的，或许，原作者的Write Paper只是编写paper吧，并不是将其正式的发表出来，暂时只能这样猜想了。</p><p>如上所说，paper的真正作用是传递思想，那么我们该怎么把我们的思想传递给读者呢？当然是要有合理明了的逻辑顺序。因此，我们有着以下的要点和行文思路：</p><ul><li>现在有个难题，我们需要解决它。</li><li>这个问题嘛，其实很有意思的，也是很有用的。</li><li>当然，这也是一个很难的尚未解决的问题，所以要我们来解决。</li><li>我现在找到一个解决方案。</li><li>这是我的方案的实现，这里详细的介绍了我的方案的实现，而且我还给了充分的数据哦！</li><li>其他人也对这问题给出了方案？好的，我的方案比他们的好多了，当然也是存在写不足的嘛！</li></ul><p>好了，行文思路我们都有了，剩下来就是实现啦！OK，我们为我们的文章编写了以下的<code>结构</code>：</p><ul><li>摘要(4句话左右)</li><li>简介(1页纸)</li><li>问题描述(1页纸)</li><li>我的方案(1页纸)</li><li>方案的具体实现情况(5页纸)</li><li>其他人的类似工作(1-2页纸)</li><li>总结和未来规划(0.5页纸)</li></ul><p>关于<code>摘要</code>，我们有下面的要求：</p><ul><li>摘要放在最后写，虽然它排在最前面</li><li>摘要的好坏决定了paper是否会被其他人阅读的</li><li>摘要的结构遵循四句话结构：<ul><li>陈述问题</li><li>说明问题的意义所在</li><li>说明我们的方案已经完成的目标</li><li>说明别人能根据我们的方案还能做些什么</li></ul></li></ul><p>写完<code>摘要</code>，我们就要写<code>简介</code>了，<code>简介</code>的主要要点如下：</p><ul><li>描述问题</li><li>阐述我们对该问题的解决做出了那些贡献：<ul><li>用列表清楚的列出我们的贡献</li><li>我们的贡献列表其实就是论文的大纲，我们的paper在后续中要一一予以论证的</li></ul></li></ul><p>接下来就是整个paper的主体了，<code>问题</code>+<code>我们的方案</code>+<code>详细实现</code>：</p><ul><li>这处不要用引用的方式向读者介绍方案，读者很难的理解我们的真正思想</li><li>具体描述方式：<ul><li>描述问题及其意义</li><li>描述我们的方案</li><li>证明我们的方案，解释我们是如何具体实现的</li></ul></li><li>使用简单的案例向读者解释，复杂的公式谁都看着头痛</li></ul><p>写完整个paper的主要部分，剩下来的就不多了。对于同一个问题，我们给出了方案，别的人也说不定有其他的方案，那么，我们就要比较一下，以显出我们的优势。我们的方案肯定也是借助了外部的其他人的工作成果的，那么我们还要在<code>相关工作</code>予以引用说明啊。</p><ul><li>如果我们借鉴了别人的成果，那么我们就要予以承认的</li><li>大度的竞争，可以请同方向的人对于paper草稿进行review</li><li>承认方案中的不足部分</li><li>我们的思路和想法必须自己的，若有冲突和重合，就要进行引用</li></ul><p>这个slide中大致给出了这些思路，若是想要看具体的实践，可以推荐Google的那些paper，这些paper都是很好遵循以上的原则的，值得一读。</p><p>PS：参考的slide可以到此处<a href="http://crazlyli0n.qiniudn.com/writing_a_paper_slides.pdf" target="_blank" rel="external">下载</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/mw690/7458d655ly1flalbaelhvj20sg0kf7wh.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;其实身为一名将来要成为码农的软工master，学术活动基本上是与我们无关的，而与写paper也几乎是绝缘的。然而因为读书报告的缘故，也是寥寥看了几篇paper，尤其是Google的那三篇牛文，更是好好的拜读了一番。读完之后，除了对&lt;code&gt;GFS&lt;/code&gt;、&lt;code&gt;MapReduce&lt;/code&gt;、&lt;code&gt;BigTable&lt;/code&gt;有了些了解外，倒是对这些paper的行文风格甚是感兴趣，觉得这些paper的行文似乎都是一脉相承，但是其思路倒是很是清晰明了。&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://xidianpanpei.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="论文" scheme="http://xidianpanpei.github.io/tags/%E8%AE%BA%E6%96%87/"/>
    
      <category term="写作" scheme="http://xidianpanpei.github.io/tags/%E5%86%99%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>FreeGate翻墙配置小技巧</title>
    <link href="http://xidianpanpei.github.io/2014/01/28/freegate-config/"/>
    <id>http://xidianpanpei.github.io/2014/01/28/freegate-config/</id>
    <published>2014-01-28T14:01:55.000Z</published>
    <updated>2017-11-13T11:34:53.942Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/7458d655ly1flalontb3rj20go0bvwrh.jpg" alt=""></p><p>作为一名程序猿，懂得翻墙是十分必要的。由于种种原因，天朝通往世界的网络上，被人为的设置了一道「长城」。然而，「长城」之外的我们向往的先进的技术和知识，也被无辜的给拒之墙外了，所以，我们都在努力的「翻墙」，不为别的，只为能够获得最为直接的技术和知识。</p><a id="more"></a><p>关于翻墙，网络最多的就是利用如何使用GAE来翻墙，鉴于这样的教程实在是多如牛毛了，也就不再赘述了。关键是在于，我是在觉得GAE的配置比较烦人，最重要的是，访问的流量有限制和速度太慢。所以，一直以来还是习惯使用FreeGate（以下简称FG）了，虽然FG是免费的，而且在Windows下，配合Firefox使用十分方便，但是，FG的使用还是需要配置一些参数，否则用起来还有些不方便。</p><p>之前，我的电脑一直是把chrome设置为默认浏览器，而且chrome也没有和FG关联上，可是每次用chrome浏览网页总是出现图片模糊甚至不可见的状态。开始以为是浏览器的问题，重装了结果还是这样，后来才发现是开了FG的原因，原来，FG默认是将自己设置为IE代理的，所以，每次用chrome的时候，其实一直都是在用代理在访问国内的网站。为此，花了点时间，好好的将FG的配置修改了一番，终于可以在不影响系统和国内访问的情况下，自由的翻墙了。</p><p>现把一些配置要点总结如下：</p><p>1.浏览器设置成Firefox或者Chrome，不要用默认的那个IE浏览器设置。FG默认的是IE，一般来说，这个要设置成我们常用的浏览器。</p><p>2.设置中勾选以下选项</p><p><img src="/img/2014/01/28/1.png" alt=""></p><p>尤其是那个不设置IE代理的选项，一定要勾选上，否则FG就会成为系统默认浏览器的代理。但是，我们的chrome或者Firefox都是使用插件控制访问代理的，所以不需要设置IE代理。</p><p>3.在代理设置中选择国内网站直通，并制定自己的规则</p><p><img src="/img/2014/01/28/2.png" alt=""></p><p>这个其实只是为了方便直接访问国内的网站，而且浏览器上的插件也带有这些功能，所以设置一下只是为了更加方便些而已。</p><p>4.通道配置，切记选择代理模式并在设置中勾选不设置IE代理，否则会造成IE和默认浏览器访问一些网站出现问题。</p><p><img src="/img/2014/01/28/3.png" alt=""></p><p>这个必须选择代理模式，由于我们在第二步中选择不设置IE代理，所以其实这项没有全部起作用，但是，如果我们不选择代理模式的话，就没有办法使用第三步中的国内网站直通选项。</p><p>关于FG的使用，大致有这些总结，以后有新的发现会继续添加。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/7458d655ly1flalontb3rj20go0bvwrh.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;作为一名程序猿，懂得翻墙是十分必要的。由于种种原因，天朝通往世界的网络上，被人为的设置了一道「长城」。然而，「长城」之外的我们向往的先进的技术和知识，也被无辜的给拒之墙外了，所以，我们都在努力的「翻墙」，不为别的，只为能够获得最为直接的技术和知识。&lt;/p&gt;
    
    </summary>
    
      <category term="杂项" scheme="http://xidianpanpei.github.io/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="freegate" scheme="http://xidianpanpei.github.io/tags/freegate/"/>
    
      <category term="翻墙" scheme="http://xidianpanpei.github.io/tags/%E7%BF%BB%E5%A2%99/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack Neutron运行机制解析概要</title>
    <link href="http://xidianpanpei.github.io/2013/12/04/openstack-neutron-mechanism-introduce/"/>
    <id>http://xidianpanpei.github.io/2013/12/04/openstack-neutron-mechanism-introduce/</id>
    <published>2013-12-04T18:40:00.000Z</published>
    <updated>2017-11-13T11:34:53.946Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/large/7458d655gw1f8mfc0qf7cj20g405kt9d.jpg" alt=""></p><p>自从开学以来，玩<code>OpenStack</code>也已经3个月了，这段时间主要把精力投在了<code>OpenStack</code>的安装部署和网络组件<code>Neutron</code>的研究上了。这期间零零散散在安装部署和<code>Neutron</code>运作原理上来回切换，有点在实践中学习的味道，虽然在安装部署的过程遇到了不少的问题，也一一都给解决了。然而，总是觉得对于<code>Neutron</code>的机制理解的还是不够透彻。前一阵子刚刚部署好一套<code>Havana</code>版本的系统，并开始投入使用。这阵子又开始投入<code>OpenStack</code>的IPv6的试验中，因为需要对底层的路由机制进行彻底的了解，所以不得不又开始重新捋了一遍这方面的知识，在网上Google了一把资料，这次算是彻底的把<code>Neutron</code>的运作机制彻底的理清楚了，之前那些半懂不懂的东西，现在也是觉得豁然开朗了。</p><a id="more"></a><p>这次在<a href="http://openstack.redhat.com/Networking_in_too_much_detail" target="_blank" rel="external">RDO</a>找到了想要的资料，至少这篇资料对于之前的那些零散的知识做了一个很好的连贯，对于自己而言，算是把<code>Neutron</code>讲解彻底明了,现在把那篇材料翻译下再糅合点自己的理解吧。</p><p>借用原资料上的一张架构图为开篇：</p><p><img src="/img/2013/12/04/Neutron_architecture.png" alt=""></p><p>从这张架构图中，我们可以明显的看到有两个物理主机，计算节点和网络节点，这是因为采用了网络节点集中式的部署方式。至于为什么采用这种部署方式，那是因为自从E版之后，<code>OpenStack</code>开始把<code>network</code>功能从<code>Nova</code>中分离出来，使之成为独立的<code>Neutron</code>组件。而坑爹的是，分离后的版本，反而不支持网络分布式部署的特性了，所以目前的<code>Grizzly</code>和<code>Havana</code>版本都是只能使用网络集中式部署方案的，或者说，集群中只能存在一个部署网络功能的节点。</p><h2 id="计算节点：虚拟机实例的网络"><a href="#计算节点：虚拟机实例的网络" class="headerlink" title="计算节点：虚拟机实例的网络"></a>计算节点：虚拟机实例的网络</h2><p>从图中看，这段网络包含了A、B、C这三段的流程。A就是虚拟机<code>test0</code>的虚拟网卡，这块没什么好讲的。和它相连的B倒是值得好好讲一下。B是一个<code>TAP</code>设备，通常是以<code>tap</code>开头的一段名称，它挂载在<code>Linux Bridge qbr</code>上面。那什么又是<code>TAP</code>设备呢？<a href="http://www.ibm.com/developerworks/cn/linux/l-virtual-networking/" target="_blank" rel="external">Linux 中的虚拟网络</a>中给出了这样的解释：</p><blockquote><p>TAP是一个虚拟网络内核驱动，该驱动实现Ethernet设备，并在Ethernet框架级别操作。TAP驱动提供了Ethernet “tap”，访问Ethernet框架能够通过它进行通信。</p></blockquote><p>总而言之，<code>TAP</code>设备其实就是一个Linux内核虚拟化出来的一个网络接口。OK，我们明白了<code>TAP</code>设备了，如果还是不明白可以查看<code>TAP</code>的具体<a href="http://vtun.sourceforge.net/tun/faq.html" target="_blank" rel="external">定义</a>。接下来就是<code>qbr</code>，这之前就说了，是一个<code>Linux Bridge</code>，很是奇怪，我们在这个架构中，使用的<code>OpenvSwitch</code>实现虚拟交换设备的，为什么会出现<code>Linux Bridge</code>呢？<a href="http://docs.openstack.org/network-admin/admin/content/under_the_hood_openvswitch.html" target="_blank" rel="external">OpenStack Networking Administration Guide</a>给出了这样的解释：</p><blockquote><p>Ideally, the TAP device vnet0 would be connected directly to the integration bridge, br-int. Unfortunately, this isn’t possible because of how OpenStack security groups are currently implemented. OpenStack uses iptables rules on the TAP devices such as vnet0 to implement security groups, and Open vSwitch is not compatible with iptables rules that are applied directly on TAP devices that are connected to an Open vSwitch port. </p></blockquote><p>其实就是说，<code>OpenvSwitch</code>不支持现在的<code>OpenStack</code>的实现方式，因为<code>OpenStack</code>是把<code>iptables</code>规则丢在<code>TAP</code>设备中，以此实现了安全组功能。没办法，所以用了一个折衷的方式，在中间加一层，用<code>Linux Bridge</code>来实现吧，这样，就莫名其妙了多了一个<code>qbr</code>网桥。在<code>qbr</code>上面还存在另一个设备C，这也是一个<code>TAP</code>设备。C通常以<code>qvb</code>开头，C和<code>br-int</code>上的D连接在一起，形成一个连接通道，使得<code>qbr</code>和<code>br-int</code>之间顺畅通信。</p><h2 id="计算节点：集成网桥-br-int-的网络"><a href="#计算节点：集成网桥-br-int-的网络" class="headerlink" title="计算节点：集成网桥(br-int)的网络"></a>计算节点：集成网桥(br-int)的网络</h2><p>刚才说到D(这也是一个<code>TAP</code>设备)在br-int上面，现在轮到<code>br-int</code>出场了，<code>br-int</code>是由<code>OpenvSwitch</code>虚拟化出来的网桥，但事实上它已经充当了一个虚拟交换机的功能了。<code>br-int</code>的主要职责就是把它所在的计算节点上的VM都连接到它这个虚拟交换机上面，然后利用下面要介绍的<code>br-tun</code>的穿透功能，实现了不同计算节点上的VM连接在同一个逻辑上的虚拟交换机上面的功能。这个似乎有点拗口，其实就是在管理员看来，所有的VM都是连接在一个虚拟交换机上面的，但事实上这些VM又都是分布在不同的物理主机上面。OK，回到D上面，D通常以qvo开头。在上面还有另一个端口E，它总是以<code>patch-tun</code>的形式出现，从字面就可以看出它是用来连接<code>br-tun</code>的。</p><h2 id="计算节点：通道网桥-br-tun-的网络"><a href="#计算节点：通道网桥-br-tun-的网络" class="headerlink" title="计算节点：通道网桥(br-tun)的网络"></a>计算节点：通道网桥(br-tun)的网络</h2><p><code>br-tun</code>在上面已经提及了，这同样是<code>OpenvSwitch</code>虚拟化出来的网桥，但是它不是用来充当虚拟交换机的，它的存在只是用来充当一个通道层，通过它上面的设备G与其他物理机上的<code>br-tun</code>通信，构成一个统一的通信层。这样的话，网络节点和计算节点、计算节点和计算节点这样就会点对点的形成一个以<code>GRE</code>为基础的通信网络，互相之间通过这个网络进行大量的数据交换。这样，网络节点和计算节点之间的通信就此打通了。而图中的G、H正是描画这一通信。</p><h2 id="网络节点：通道网桥（br-tun）的网络"><a href="#网络节点：通道网桥（br-tun）的网络" class="headerlink" title="网络节点：通道网桥（br-tun）的网络"></a>网络节点：通道网桥（br-tun）的网络</h2><p>正如前面所说，网络节点上也是存在一个<code>br-tun</code>，它的作用同计算节点上的<code>br-tun</code>如出一辙，都是为了在整个系统中构建一个统一的通信层而存在的。所以，这一部分的网络同计算节点上的网络的功能是一致的，因此，也就没有必要多说了。</p><h2 id="网络节点：集成网桥（br-int）的网络"><a href="#网络节点：集成网桥（br-int）的网络" class="headerlink" title="网络节点：集成网桥（br-int）的网络"></a>网络节点：集成网桥（br-int）的网络</h2><p>网络节点上的<code>br-int</code>也是起了交换机的作用，它通过I、J与<code>br-tun</code>连接在一起。最终的要的是，在这个虚拟交换机上，还有其他两个重要的<code>tap</code>设备M、O，它们分别同N、P相连，而N、P作为<code>tap</code>设备则是分别归属两个<code>namespace</code>router和dhcp，没错，正如这两个<code>namespace</code>的名称所示，它们承担的就是router和dhcp的功能。这个router是由<code>l3-agent</code>根据网络管理的需要而创建的，然后，该router就与特定一个子网绑定到一起，管理这个子网的路由功能。router实现路由功能，则是依靠在该<code>namespace</code>中的<code>iptables</code>实现的。dhcp则也是<code>l3-agent</code>根据需要针对特定的子网创建的，在这个<code>namespace</code>中，<code>l3-agent</code>会启动一个<code>dnsmasq</code>的进程，由它来实际掌管该子网的dhcp功能。由于这个两个<code>namespace</code>都是针对特定的子网创建的，因而在现有的<code>OpenStack</code>系统中，它们常常是成对出现的。</p><h2 id="网络节点：外部网桥（br-ex）的网络"><a href="#网络节点：外部网桥（br-ex）的网络" class="headerlink" title="网络节点：外部网桥（br-ex）的网络"></a>网络节点：外部网桥（br-ex）的网络</h2><p>当数据从router中路由出来后，就会通过L、K传送到<code>br-ex</code>这个虚拟网桥上，而<code>br-ex</code>实际上是混杂模式加载在物理网卡上，实时接收着网络上的数据包。至此，我们的计算节点上的VM就可以与外部的网络进行自由的通信了。当然，前提是我们要给这个VM已经分配了<code>float-ip</code>。</p><p>关于OpenStack Neutron的分析大致描述这些吧，后续的话会详细的写一些文章来详细介绍整个的详细流程和相关的实现方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/7458d655gw1f8mfc0qf7cj20g405kt9d.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;自从开学以来，玩&lt;code&gt;OpenStack&lt;/code&gt;也已经3个月了，这段时间主要把精力投在了&lt;code&gt;OpenStack&lt;/code&gt;的安装部署和网络组件&lt;code&gt;Neutron&lt;/code&gt;的研究上了。这期间零零散散在安装部署和&lt;code&gt;Neutron&lt;/code&gt;运作原理上来回切换，有点在实践中学习的味道，虽然在安装部署的过程遇到了不少的问题，也一一都给解决了。然而，总是觉得对于&lt;code&gt;Neutron&lt;/code&gt;的机制理解的还是不够透彻。前一阵子刚刚部署好一套&lt;code&gt;Havana&lt;/code&gt;版本的系统，并开始投入使用。这阵子又开始投入&lt;code&gt;OpenStack&lt;/code&gt;的IPv6的试验中，因为需要对底层的路由机制进行彻底的了解，所以不得不又开始重新捋了一遍这方面的知识，在网上Google了一把资料，这次算是彻底的把&lt;code&gt;Neutron&lt;/code&gt;的运作机制彻底的理清楚了，之前那些半懂不懂的东西，现在也是觉得豁然开朗了。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenStack" scheme="http://xidianpanpei.github.io/categories/OpenStack/"/>
    
    
      <category term="OpenStack" scheme="http://xidianpanpei.github.io/tags/OpenStack/"/>
    
      <category term="Neutron" scheme="http://xidianpanpei.github.io/tags/Neutron/"/>
    
  </entry>
  
  <entry>
    <title>JUnit-3.8.1源码分析</title>
    <link href="http://xidianpanpei.github.io/2013/11/01/analyze-junit-source-code/"/>
    <id>http://xidianpanpei.github.io/2013/11/01/analyze-junit-source-code/</id>
    <published>2013-11-01T10:02:00.000Z</published>
    <updated>2017-11-13T11:34:53.938Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/7458d655gw1f8mfu726tej20wi0egdkj.jpg" alt=""></p><p>JUnit是由Erich Gamma和Kent Beck编写的一个开源的单元测试框架。它属于白盒测试，只要将待测类继承TestCase类，就可以利用JUnit的一系列机制进行便捷的自动测试了。</p><a id="more"></a><p>JUnit的设计精简，易学易用，但是功能却非常强大，这归因于它内部完善的代码结构。JUnit中深深渗透了扩展性优良的设计模式思想。JUnit提供的API既可以让您写出测试结果明确的可重用单元测试用例，也提供了单元测试用例成批运行的功能。在已经实现的框架中，用户可以选择三种方式来显示测试结果，并且 显示的方式本身也是可扩展的。</p><p>###JUnit系统架构<br>通过分析JUnit-3.8.1的源代码文件可以看到，JUnit的源码被分散在6个package中，这个6个package分别为：<code>junit.awtui</code>、<code>junit.swingui</code>、<code>junit.textui</code>、<code>junit.extensions</code>、<code>junit.framework</code>、<code>junit.runner</code>。具体的文件分布图如下：</p><p><img src="http://ww4.sinaimg.cn/large/7458d655gw1f70ojps32aj207405gt93.jpg" alt=""></p><p>通过对源码的分析，我们可以知道，其中<code>junit.awtui</code>、<code>junit.swingui</code>、<code>junit.textui</code>这三个package是有关JUnit运行时的入口程序以及运行结果显示界面的，junit.runner中则包含了支持单元测试运行的一些基础类以及自己的类加载器，这四个package的运行逻辑对于JUnit的用户来说，都是透明无法感知的，用户只能感知到JUnit测试时的运行界面以及相关的运行结果的展示。<code>junit.extensions、junit</code>.framework这两个package则是JUnit中的核心部分了，其中junit.framework 包含有编写一般JUnit单元测试类必须是用到的JUnit类；而junit.extensions则是对framework包在功能上的一些必要扩展以及为更多的功能扩展留下的接口。</p><p>通过对JUnit源码的package分析，可以得到以下三个package的类图：<br>1.<code>junit.framework</code>的类图<br><img src="http://ww4.sinaimg.cn/large/7458d655gw1f70ojpmbi0j20jq0fugmb.jpg" alt=""></p><p>2.<code>junit.extensions</code>的类图<br><img src="http://ww1.sinaimg.cn/large/7458d655gw1f70ojp4d21j20eg0h8wf1.jpg" alt=""></p><p>3.<code>junit.runner</code>的类图<br><img src="http://ww1.sinaimg.cn/large/7458d655gw1f70ojpmyo4j20lo0hsdgy.jpg" alt=""></p><p>###JUnit工作流程解析<br>Junit的主要功能就是简化单元测试，由于其代码中使用了很多的设计模式，因此纯粹从源码的角度分析其工作流程相对比较复杂，因此此处使用一个简单的测试用例来描述Junit的工作流程，这样会更容易理解其流程时序。</p><p><img src="http://ww4.sinaimg.cn/large/7458d655gw1f70ojpm1j9j20h8052t9b.jpg" alt=""></p><p>这段代码为一个我们将要测试的类，其中只有一个简单的<code>add()</code>方法，其功能是实现两个double类型的数值相加。</p><p>接下来我们将会对其编写对应的JUnit测试代码。</p><p><img src="http://ww1.sinaimg.cn/large/7458d655gw1f70ojq19z4j20j60i4adp.jpg" alt=""></p><p>在上述测试代码中，我们的测试类<code>TestCalculator</code>继承了<code>TestCase</code>类（当然，我们还有一种编写方式不用继承<code>TestCase</code>类，但是我们需要在每个测试方法上添加@Test的注解），在测试类中，我们编写了<code>testAdd()</code>测试方法，同时一个必然失败的测试方法<code>testFail()</code>，这样可以便于我们更全面的了解JUnit运行机制。</p><p>通过对上述测试代码的分析以及JUnit源码的分析，我们可以为此次的用例总结出以下的时序图，这张图为我们清楚的展示了JUnit实现单元测试的内部机制。</p><p><img src="http://ww4.sinaimg.cn/large/7458d655gw1f70ojr7r2bj20jy0g175i.jpg" alt=""></p><p>JUnit的完整生命周期分为3个阶段：初始化阶段、运行阶段和结果捕捉阶段。</p><p>1.初始化阶段：</p><p><img src="http://ww2.sinaimg.cn/large/7458d655gw1f70ojpagt5j20e408140g.jpg" alt=""></p><p>通过分析源码，可以看到JUnit的入口点在<code>junit.textui.TestRunner</code>的<code>main</code>方法，在这个方法中，首先创建一个<code>TestRunner</code>实例<code>aTestRunner</code>，然后<code>main</code>函数中主体工作函数为<code>TestResult r = aTestRunner.start(args)</code>。此时<code>TestRunner</code>实例存在并开始工作。接下来进入<code>start()</code>方法中：</p><p><img src="http://ww4.sinaimg.cn/large/7458d655gw1f70ojphsxkj20ug0gjwj2.jpg" alt=""></p><p>首先，对于参数的检查和解析。接下来通过<code>Test suite= getTest(testCase)</code>将对<code>testCase</code>持有的全限定名进行解析，并构造<code>TestSuite</code>。进入<code>getTest</code>方法中：</p><p><img src="http://ww3.sinaimg.cn/large/7458d655gw1f70ojq6vwhj20gn0ifq7u.jpg" alt=""></p><p>在这段代码中，<code>TestSuite</code>实例开始被构造，而通过代码可以知道，构造方式分为：用户在测试类中通过声明<code>Suite()</code>方法自定义TestSuite和JUnit自动判断并提取测试方法两种方式。接下来就进入<code>TestSuite</code>类中构造方法<code>public TestSuite(final Class theClass)</code>。</p><p><img src="http://ww3.sinaimg.cn/large/7458d655gw1f70ojpejf2j20j407d76o.jpg" alt=""></p><p>在这中间，可以可以看到测试用例由<code>addTestMethod</code>方法全部添加到<code>TestSuite</code>中，继续跟进<code>addTestMethod</code>方法：</p><p><img src="http://ww1.sinaimg.cn/large/7458d655gw1f70ojpvbvbj20kl07uac9.jpg" alt=""></p><p>在这中间可以看到<code>addTestMethod</code>的具体实现，主要的就是<code>addTest</code>，其实这个方法只是简单封装了一个对全局的容器变量<code>fTests</code>的添加值操作。最重要的还是那个<code>createTest</code>方法，进入看看细节：</p><p><img src="http://ww3.sinaimg.cn/large/7458d655gw1f70ojreir4j20ux0g1q9l.jpg" alt=""></p><p>在这中间就可以看到各个测试用例方法通过反射机制：<code>test= constructor.newInstance(new Object[]{name})</code>转化成一个个<code>TestCase</code>实例。<br>至此，JUnit的初始化过程就结束了。</p><p>2.测试运行阶段：</p><p>在<code>TestRunner</code>中的<code>start()</code>方法中可以看到开始调用<code>doRun()</code>方法开始执行测试了。</p><p><img src="http://ww3.sinaimg.cn/large/7458d655gw1f70ojpdkxvj20je04yaav.jpg" alt=""></p><p>进入<code>doRun()</code>方法中可以看到：</p><p><img src="http://ww2.sinaimg.cn/large/7458d655gw1f70ojpnntxj20f507wac3.jpg" alt=""></p><p>首先是利用<code>createTestResult()</code>方法生成一个<code>TestResult</code>实例，而<code>createTestResult()</code>方法其实也就是new一个<code>TestResult</code>实例，然后将<code>junit.textui.TestRunner</code>的监听器<code>fPrinter</code>加入到result 的监听器列表中。其中，<code>fPrinter</code>是<code>junit.textui.ResultPrinter</code>类的实例，该类提供了向控制台输出测试结果的一系列功能接口，输出的格式在类中定义。<code>ResultPrinter</code>类实现了<code>TestListener</code>接口，具体实现了<code>addError</code>、<code>addFailure</code>、<code>endTest</code>和<code>startTest</code>四个重要的方法，这种设计体现了Observer设计模式。而将<code>ResultPrinter</code>对象加入到<code>TestResult</code>对象的监听器列表中，因此实质上<code>TestResult</code>对象可以有多个监听器显示测试结果。<br>接下来我们查看run方法，可以看到：</p><p><img src="http://ww1.sinaimg.cn/large/7458d655gw1f70ojql4mcj20h907uwg5.jpg" alt=""></p><p>此处JUnit代码颇具说服力地说明了Composite模式的效力，run接口方法的抽象具有重大意义，它实现了客户代码与复杂对象容器结构的解耦，让对象容器自己来实现自身的复杂结构，从而使得客户代码就像处理简单对象一样来处理复杂的对象容器。每次循环得到的节点test，都同result一起传递给<code>runTest</code>方法，进行下一步更深入的运行。<br>在这样递归的运行之后， <code>junit.framework.TestResult.run</code>相应的结果<code>TestResult</code>实例中：</p><p><img src="http://ww4.sinaimg.cn/large/7458d655gw1f70ojq2m4ej20eo08wwfv.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/7458d655gw1f70ojq38srj20j80930ud.jpg" alt=""></p><p>这中间实现了<code>Protectable</code>接口的匿名类的实例，<code>runProtected</code>则是实际把那个刚刚实现的匿名类实例中的<code>runBare()</code>方法执行了。</p><p><img src="http://ww4.sinaimg.cn/large/7458d655gw1f70ojq9d4xj20f208cdgw.jpg" alt=""></p><p>在该方法中，最终的测试会传递给一个<code>runTest</code>方法执行，注意此处的<code>unTest</code>方法是无参的，注意与之前形似的方法区别。该方法中也出现了经典的<code>setUp</code>方法和<code>tearDown</code>方法，追溯代码可知它们的定义为空。用户可以覆盖两者，进行一些fixture的自定义和搭建。这中间其实就蕴含了模板模式的思想了。<br>其中，最为主要的还是<code>runTest()</code>方法：</p><p><img src="http://ww3.sinaimg.cn/large/7458d655gw1f70ojr43xyj20g90fxgq9.jpg" alt=""></p><p>在这里，通过反射机制<code>runMethod= getClass().getMethod(fName, null);</code>提取<code>TestCase</code>中的方法，然后为每一个测试方法，创建一个方法对象<code>unMethod</code>并调用<code>runMethod.invoke(this, new Class[0]);</code>，至此，用户测试方法的代码才开始真正被运行起来。当然剩下就是些异常捕获和处理。</p><p>3.测试结果捕捉阶段：</p><p>运行已经完成了，现在就是看结果了，当一切都是OK，当然是没问题啦。</p><p><img src="http://ww4.sinaimg.cn/large/7458d655gw1f70ojq35f8j20iy0aq766.jpg" alt=""></p><p>当出现错误了或者失败，我们就catch到相应的Error或者Fail，然后用<code>addFailure</code>加入到监听器<code>TestListener</code>中，当然为了区分不同，还可以用<code>addError</code>添加。然后就可以由<code>ResultPrinter</code>将结果输出了：</p><p><img src="http://ww3.sinaimg.cn/large/7458d655gw1f70ojq44d4j20lv08tgnp.jpg" alt=""></p><p>###主要设计模式<br>JUnit中间，使用的设计模式是比较多的，JUnit应该来说是一个学习设计模式的很好的范例。</p><p>在前面的JUnit工作流程分析的单元中，分析过程中，我们已经看到了组合模式（Composite Pattern）：</p><p><img src="http://ww1.sinaimg.cn/large/7458d655gw1f70ojql4mcj20h907uwg5.jpg" alt=""></p><p>其中的run接口方法的抽象实现了客户代码与复杂对象容器结构的解耦，让对象容器自己来实现自身的复杂结构，从而使得客户代码就像处理简单对象一样来处理复杂的对象容器。</p><p>另外，<code>TestCase</code>中<code>runBare()</code>方法则是模板模式的典型范例：</p><p><img src="http://ww2.sinaimg.cn/large/7458d655gw1f70ojq7s8xj20f208cdgw.jpg" alt=""></p><p>这处则是充分体现了模板模式中将一些步骤延迟到子类中的思想。</p><p>而观察者模式则是体现在下方：<br><code>TestResult</code>并不是一个记录测试结果的类，而是观察者模式中的主题角色。每个<code>TestCase</code>运行的时候都是用<code>TestResult</code>来运行的，这样才能通知每个观察者方法要开始运行了。在这里，观察者就是那些显示方式，比如Text,Swing,Awt那几种UI的显示类。</p><p>命令模式则是表现在编写测试用例时，JUnit只是一个测试用例的执行器和结果查看器，而与实际用例的编写没有关联，处于完全解耦的状态。</p><p>###参考资料<br>[1]《分析JUnit框架源代码》，何正华、徐晔，<a href="http://www.ibm.com/developerworks/cn/java/j-lo-junit-src/" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/java/j-lo-junit-src/</a><br>[2]《JUnit源码分析》，匿名，<a href="http://blog.csdn.net/ai92/article/details/318318" target="_blank" rel="external">http://blog.csdn.net/ai92/article/details/318318</a><br>[3]《HeadFirst设计模式》，Freeman,E.,O’Reilly Taiwan公司译，中国电力出版社<br>[4] JUnit-3.8.1源码</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/7458d655gw1f8mfu726tej20wi0egdkj.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;JUnit是由Erich Gamma和Kent Beck编写的一个开源的单元测试框架。它属于白盒测试，只要将待测类继承TestCase类，就可以利用JUnit的一系列机制进行便捷的自动测试了。&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://xidianpanpei.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JUnit" scheme="http://xidianpanpei.github.io/tags/JUnit/"/>
    
      <category term="源码分析" scheme="http://xidianpanpei.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="开源" scheme="http://xidianpanpei.github.io/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>commons-logging 源码简析</title>
    <link href="http://xidianpanpei.github.io/2013/09/26/commons-loggings-analysis/"/>
    <id>http://xidianpanpei.github.io/2013/09/26/commons-loggings-analysis/</id>
    <published>2013-09-26T09:21:00.000Z</published>
    <updated>2017-11-13T11:34:53.942Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww3.sinaimg.cn/large/7458d655gw1f8mfvg7yelj21kw11x7wh.jpg" alt=""></p><h2 id="日志系统简介"><a href="#日志系统简介" class="headerlink" title="日志系统简介"></a>日志系统简介</h2><p>应用程序中使用日志功能能够方便的调试和跟踪应用程序任意时刻的行为和状态。在大规模的应用开发中尤其重要，毫不夸张的说，日志系统是不可或缺的重要组成部分。由于开源的广泛性，我们不需要再去重复造轮子，我们可以直接使用众多的开源日志系统来满足我们的开发需求。</p><a id="more"></a><p>目前使用最多的日志系统主要有slf4j、commons-logging这样的“门面”日志系统，也有log4j、logback这样的实际执行日志系统。slf4j、commons-logging这类系统它们本身并不是直接实现具体的日志打印逻辑，而只是作为一个代理系统，接收应用程序的日志打印请求，然后根据当前环境和配置，选取一个具体的日志实现系统，将真正的打印逻辑交给具体的日志实现系统，从而实现应用程序日志系统的“可插拔”，即可以通过配置或更换jar包来方便的更换底层日志实现系统，而不需要改变任何代码。</p><p>出于对日志系统的深入学习，我们这次对commons-logging进行源码分析。</p><h2 id="commons-logging源码分析"><a href="#commons-logging源码分析" class="headerlink" title="commons-logging源码分析"></a>commons-logging源码分析</h2><p>我们对下载得到的commons-logging源码进行展开，很容得到commons-logging代码的主要代码结构。</p><p><img src="http://ww1.sinaimg.cn/large/7458d655gw1f70ojqakaqj20870alta8.jpg" alt=""></p><p>其中的，部分代码文件已经作废，至于为什么没有删除掉，这就不得而知了。其中的LogSource.java文件已经作废，而其功能职责则由LogFactory.java代替。LogFactory.java实际只是一个实现接口，具体的实现则是由继承LogFactory.java的LogFactoryImpl.java来完成了。目录中众多其他实现文件则是继承自Log.java接口，对其实现了不同的功能，完成底层的对不同的实际执行日志系统的适配。主要是配有：AvalonLogger、Jdk13LumberjackLogger、Jdk14Logger、Log4JLogger、LogKitLogger、SimpleLog。还有一个ServletContextCleaner.java则是为了WebApp相关项目而准备，用于释放有关的内存。</p><p><img src="http://ww1.sinaimg.cn/large/7458d655gw1f70ojqi8bzj20gl07l74v.jpg" alt=""></p><p>在LogFactory中定义了一定的规则，从而根据当前的环境和配置取得特定的Log子类实例。</p><p>Commons Logging中默认实现的LogFactory（LogFactoryImpl类）查找具体Log实现类的逻辑如下：<br>1.查找在commons-logging.properties文件中是否定存在以org.apache.commons.logging.Log或org.apache.commons.logging.log(旧版本，不建议使用)为key定义的Log实现类，如果是，则使用该类。<br>2.否则，查找在系统属性中（-D方式启动参数）是否存在以org.apache.commons.logging.Log或org.apache.commons.logging.log(旧版本，不建议使用)为key定义的Log实现类，如果是，则使用该类。<br>3.否则，如果在classpath中存在Log4J的jar包，则使用Log4JLogger类。<br>4.否则，如果当前使用的JDK版本或等于1.4，则使用Jdk14Logger类。<br>5.否则，如果存在Lumberjack版本的Logging系统，则使用Jdk13LumberjackLogger类。<br>6.否则，如果可以正常初始化Commons Logging自身实现的SimpleLog实例，则使用该类。<br>7.最后，以上步骤都失败，则抛出LogConfigurationException。  </p><p>我们在使用Commons-Logging的时候，一般都是通过LogFacotry获取Log实例的，然后调用Log接口中相应的方法，而这是一个典型的工厂设计模式。Commons-Logging的实现可以分成以下几个步骤：<br><strong>1.LogFactory类初始化：</strong><br>a.缓存加载LogFactory的ClassLoader（thisClassLoader字段），出于性能考虑。因为getClassLoader()方法以后会使用AccessController，因而缓存起来以提升性能。<br>b.初始化诊断流。读取系统属性org.apache.commons.logging.diagnostics.dest，若该属性的值为STDOUT、STDERR、文件名。则初始化诊断流字段（diagnosticStream），并初始化诊断消息的前缀（diagnosticPrefix），其格式为：“[LogFactory from ]”, 该前缀用于处理在同一个应用程序中可能会有多个ClassLoader加载LogFactory实例的问题。<br>c.如果配置了诊断流，则打印当前环境信息：java.ext.dir、java.class.path、ClassLoader以及ClassLoader层级关系信息。<br>d.初始化factories实例（Hashtable），用于缓存LogFactory（context-classloader –-&lt; LogFactory instance）。如果系统属性org.apache.commons.logging.LogFactory.HashtableImpl存在，则使用该属性定义的Class作为factories Hashtable的实现类，否则，使用Common Logging实现的WeakHashtable。若初始化没有成功，则使用Hashtable类本身。使用WeakHashtable是为了处理在webapp中，当webapp被卸载是引起的内存泄露问题，即当webapp被卸载时，其ClassLoader的引用还存在，该ClassLoader不会被回收而引起内存泄露。因而当不支持WeakHashtable时，需要卸载webapp时，调用LogFactory.relase()方法。<br>e.最后，如果需要打印诊断信息，则打印“BOOTSTRAP COMPLETED”信息。  </p><p><strong>2.查找LogFactory类实现，并实例化：</strong><br>当调用LogFactory.getLog()方法时，它首先会创建LogFactory实例(getFactory())，然后创建相应的Log实例。getFactory()方法不支持线程同步，因而多个线程可能会创建多个相同的LogFactory实例，由于创建多个LogFactory实例对系统并没有影响，因而可以不用实现同步机制。<br>a.获取context-classloader实例。<br>b.从factories Hashtable（缓存）中获取LogFactory实例。<br>c.读取commons-logging.properties配置文件（如果存在的话，如果存在多个，则可以定义priority属性值，取所有commons-logging.properties文件中priority数值最大的文件），如果设置use_tccl属性为false，则在类的加载过程中使用初始化cache的thisClassLoader字段，而不用context ClassLoader。<br>d.查找系统属性中是否存在org.apache.commons.logging.LogFactory值，若有，则使用该值作为LogFactory的实现类，并实例化该LogFactory实例。<br>e.使用service provider方法查找LogFactory的实现类，并实例化。对应Service ID是：META-INF/services/org.apache.commons.logging.LogFactory<br>f.查找commons-logging.properties文件中是否定义了LogFactory的实现类：org.apache.commons.logging.LogFactory，是则用该类实例化一个出LogFactory<br>g.否则，使用默认的LogFactory实现：LogFactoryImpl类。<br>h.缓存新创建的LogFactory实例，并将commons-logging.properties配置文件中所有的键值对加到LogFactory的属性集合中。  </p><p><strong>3.通过LogFactory实例查找Log实例（LogFactoryImpl实现）：</strong><br>使用LogFactory实例调用getInstance()方法取得Log实例。<br>a.如果缓存（instances字段，Hashtable）存在，则使用缓存中的值。<br>b.查找用户自定义的Log实例，即从先从commons-logging.properties配置文件中配置的org.apache.commons.logging.Log（org.apache.commons.logging.log，旧版本）类，若不存在，查找系统属性中配置的org.apache.commons.logging.Log（org.apache.commons.logging.log，旧版本）类。如果找到，实例化Log实例<br>c.遍历classesToDiscover数组，尝试创建该数组中定义的Log实例，并缓存Log类的Constructor实例，在下次创建Log实例是就不需要重新计算。在创建Log实例时，如果use_tccl属性设为false，则使用当前ClassLoader（加载当前LogFactory类的ClassLoader），否则尽量使用Context ClassLoader，一般来说Context ClassLoader和当前ClassLoader相同或者是当前ClassLoader的下层ClassLoader，然而在很多自定义ClassLoader系统中并没有设置正确的Context ClassLoader导致当前ClassLoader成了Context ClassLoader的下层，LogFactoryImpl默认处理这种情况，即使用当前ClassLoader。用户可以通过设置org.apache.commons.logging.Log.allowFlawedContext配置作为这个特性的开关。<br>d.如果Log类定义setLogFactory()方法，则调用该方法，将当前LogFactory实例传入。<br>e.将新创建的Log实例存入缓存中。  </p><p><strong>4.调用Log实例中相应的方法</strong>  </p><p>通过对commons-logging的分析，可以发现其实现的思路相对来说还是比较简单的，源码的整体结构也非常清晰，代码的数量也不是很多，里面的注释也是十分的清晰明了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww3.sinaimg.cn/large/7458d655gw1f8mfvg7yelj21kw11x7wh.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;日志系统简介&quot;&gt;&lt;a href=&quot;#日志系统简介&quot; class=&quot;headerlink&quot; title=&quot;日志系统简介&quot;&gt;&lt;/a&gt;日志系统简介&lt;/h2&gt;&lt;p&gt;应用程序中使用日志功能能够方便的调试和跟踪应用程序任意时刻的行为和状态。在大规模的应用开发中尤其重要，毫不夸张的说，日志系统是不可或缺的重要组成部分。由于开源的广泛性，我们不需要再去重复造轮子，我们可以直接使用众多的开源日志系统来满足我们的开发需求。&lt;/p&gt;
    
    </summary>
    
      <category term="学习" scheme="http://xidianpanpei.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="开源" scheme="http://xidianpanpei.github.io/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="commons-logging" scheme="http://xidianpanpei.github.io/tags/commons-logging/"/>
    
  </entry>
  
  <entry>
    <title>利用Python简单搜索人人网好友关系</title>
    <link href="http://xidianpanpei.github.io/2013/09/08/renren-friends-connect-search-by-python/"/>
    <id>http://xidianpanpei.github.io/2013/09/08/renren-friends-connect-search-by-python/</id>
    <published>2013-09-08T17:23:00.000Z</published>
    <updated>2017-11-13T11:34:53.946Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww1.sinaimg.cn/large/7458d655gw1f8mfyjqy7xj20dw09uq4q.jpg" alt=""></p><p>最近乘着开学的时候还没有什么事情，于是乎，开始学起了Python。Python作为脚本语言，最近一段时间真的是越来越火了，所以也有必要认真的学习一下的。毕竟多学一门语言也不是坏事，而且看上去，Python的学习门槛不是太高，只是在一些库上的学习和应用值得花些时间好好钻研一下。</p><a id="more"></a><p>不得不说Python由于去掉很多的数据类型，封装了很多的功能，加上那丰富的库，真的让开发变得很是容易，代码量更是大大的减少了。然而，并不是像很多其他人那样，总是推荐新手去学习Python，我个人认为如果只是玩玩编程而已，Python的确是个不错的选择，但是如果想要深入学习的话，还是拿C这类的语言来入门吧，虽然门槛要高一些，但是更能去理解程序的执行原理(当然，汇编之类的更是容易了解程序的执行原理，但大多数人还是愿意用稍微高级些的语言，毕竟我们不是机器人)，而且以后学习其他的语言也是更容易一些入门。</p><p>废话不多说了，这些也就是顺便一提。</p><p>爬取人人网上的好友信息也就是看到别人有弄过，觉得也挺好玩的。之前从来没有使用开放平台的<code>APIs</code>开发过的经验，于是也就是在人人上注册了开发者的账号，获取到<code>accesskey</code>，然后拿着那刚开始入门的Python开始胡乱的写了起来。我的目的也是很简单的，就是写个简单的爬虫，爬点人人网上的好友信息玩玩。想来想去，也就好友之间的关系图看起来挺有意思的，于是找到相应的接口，胡乱的玩起来，而主要就是根据一个好友的id，然后搜索到其所有的好友id，然后是好友的好友的id，如此重复下去。理论上来说，这样一直爬下去的话，应该是可以爬完整个人人网上的id(那些僵尸账号是爬不到的，孤立在整个网络之外的孤点估计都没有办法爬到的)，然后将好友写入文件或者数据库，有机会的话还打算用<code>d3.js</code>。刚开始是用好友关系列表中获取到相应的好友id，当时只注意到这个API。今天突然发现还有个直接获取好友ID列表的API，很当然就用了这个接口。</p><p>目前的这个简单的爬虫很是粗糙，虽然暂时能爬取好友列表，但是暂时还是无法解决关系网中存在的回环问题，其实这个问题只要进行id去重就好，可是利用内存表去重的话，怕是到后来随着id表的规模的扩大导致内存吃不消，同时性能更是糟糕。其实，可以数据库来去重的，可惜暂时不打算使用数据库。利用文件存储也是可以的，但是怕到时候频繁的I/O造成性能下降。总之，还是等到后面再想办法吧。还有个就是万恶的人人网的访问请求限制，今天刚跑到1w的关系量就被禁止了。</p><p>多说也是无益啊，还是先贴上粗糙的代码吧！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#name:renren-friend.py</span></span><br><span class="line"><span class="comment">#--*utf-8*--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> urllib2</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(queue, datafile)</span>:</span></span><br><span class="line">    url = <span class="string">"https://api.renren.com/v2/friend/list?"</span></span><br><span class="line">    access_token = <span class="string">"access_token=put your access_token here"</span></span><br><span class="line">    id = queue.get()</span><br><span class="line">    userId = <span class="string">"userId=%d"</span> %id</span><br><span class="line">    <span class="comment">#pageSize设置为7000是为了一次性获取所有好友ID，人人网的VIP好友上线是7000</span></span><br><span class="line">    data = url + access_token + <span class="string">"&amp;"</span> + userId + <span class="string">"&amp;pageSize=7000"</span></span><br><span class="line"></span><br><span class="line">    response_text = urllib2.urlopen(data)</span><br><span class="line">    <span class="comment">#睡眠5秒，为了防止人人网的访问频繁的限制，事实证明还是太低了，估计得设置到2分钟</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    s = response_text.read()</span><br><span class="line">    response = json.loads(s)</span><br><span class="line"></span><br><span class="line">    r = response[<span class="string">'response'</span>]</span><br><span class="line">    length = len(r)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">        queue.put(r[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"---&gt; %d"</span> %r[i]</span><br><span class="line"></span><br><span class="line">        strword = <span class="string">"%d%s%d%s"</span> %(id, <span class="string">" "</span>, r[i], <span class="string">"\n"</span>)</span><br><span class="line">        datafile.write(strword)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    fp = open(<span class="string">"friends.txt"</span>, <span class="string">"w"</span>)</span><br><span class="line">    queue = Queue.Queue()</span><br><span class="line">    queue.put(<span class="number">100896521</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> queue.empty():</span><br><span class="line">        work(queue, fp)</span><br><span class="line"></span><br><span class="line">    fp.close()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"------end the search-------"</span></span><br></pre></td></tr></table></figure><p>第一版的粗糙的代码暂时贴在这里吧，后面还是要花点时间继续改进，同时也要好好的学习Python的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww1.sinaimg.cn/large/7458d655gw1f8mfyjqy7xj20dw09uq4q.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近乘着开学的时候还没有什么事情，于是乎，开始学起了Python。Python作为脚本语言，最近一段时间真的是越来越火了，所以也有必要认真的学习一下的。毕竟多学一门语言也不是坏事，而且看上去，Python的学习门槛不是太高，只是在一些库上的学习和应用值得花些时间好好钻研一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://xidianpanpei.github.io/categories/Python/"/>
    
    
      <category term="爬虫" scheme="http://xidianpanpei.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="Python" scheme="http://xidianpanpei.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>使用Git管理开发代码的一点理解</title>
    <link href="http://xidianpanpei.github.io/2013/09/05/some-talk-about-the-code-manage-with-git/"/>
    <id>http://xidianpanpei.github.io/2013/09/05/some-talk-about-the-code-manage-with-git/</id>
    <published>2013-09-05T21:18:00.000Z</published>
    <updated>2017-11-13T11:34:53.946Z</updated>
    
    <content type="html"><![CDATA[<p>最近也算是把Git相关的知识看了不少了，虽然对于Git的有些命令还是没怎么熟记，对一些更加高级的命令也是没有实践过，但慢慢理解了Git的相关的flow之后，不自然就和以前用过的SVN进行了一些对比，发现Git相对于SVN来说的确有些优势。</p><p>在之前的公司里，项目组一直是用SVN来做相关的版本管理的，当然，我这种底层的开发小兵也不需要用到SVN的版本控制层面的功能的。我所能使用的，也就是提交代码，查看提交日志等一些一线开发人员常用的功能而已。当初记得，项目组的SE经常提出新的需求，同时，测试也在不停提出bug修改要求，所以总是把代码一份一份的拷贝到不同的文件夹中，然后对于不同文件夹的代码进行不同的代码功能修复或者开发，最后合并到最初的SVN源码文件夹中。不得不说，这是一种非常原始的方式，但是这是我当时能够最有效的代码控制的方式了，因为经过自己的实践证明，这种方式可以合理规避掉各种的代码覆盖冲突等问题。至今还对于用BeyondCompare一行行比对代码的事记忆犹新啊。</p><a id="more"></a><p>然而，随着了解Git的相关的一些知识后，蓦然发现，原来我使用过的那种原始代码控制方式，已经在Git中完美的实现了(唯一可能不满意就是Git中diff工具没有BeyondCompare那么强大吧，当年一直对于代码冲突导致的文件内容混乱非常反感)。看了不少的关于Git分支管理的布道文章后，加上自己的那套原始的代码控制方式，从而也对使用Git有效管理控制代码有了些自己的见解。</p><p><img src="/img/2013/09/05/git-flow.png" alt=""></p><p>在我看来，我们clone完项目组的代码之后，此时的分支为master，那么我们应该一直保持此分支的干净整洁，不要在master分支上直接进行开发。我们应该在开始一项新的主功能的开发时，从master分支分离出一直develop分支，日常的开发应该在此分支之上。同时，根据的以后的附加功能的需要，我们应该考虑是从master分支分离分支开发还是从develop分支分离分支开发，对于bug的修复同样需要如此考虑。当我们开发完成该项主功能后，应该清理干净从develop分支上分离的各个分支，然后保证develop分支干净后，将其合入最新的master分支，最后将最新的master分支push到远程仓库中。另外，在整个开发过程中，对于master分支我们时常保持其最新程度，要时常更新master分支上的代码，这样可以便于我们同其他开发者的同步，也减小了覆盖别人代码的几率。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近也算是把Git相关的知识看了不少了，虽然对于Git的有些命令还是没怎么熟记，对一些更加高级的命令也是没有实践过，但慢慢理解了Git的相关的flow之后，不自然就和以前用过的SVN进行了一些对比，发现Git相对于SVN来说的确有些优势。&lt;/p&gt;
&lt;p&gt;在之前的公司里，项目组一直是用SVN来做相关的版本管理的，当然，我这种底层的开发小兵也不需要用到SVN的版本控制层面的功能的。我所能使用的，也就是提交代码，查看提交日志等一些一线开发人员常用的功能而已。当初记得，项目组的SE经常提出新的需求，同时，测试也在不停提出bug修改要求，所以总是把代码一份一份的拷贝到不同的文件夹中，然后对于不同文件夹的代码进行不同的代码功能修复或者开发，最后合并到最初的SVN源码文件夹中。不得不说，这是一种非常原始的方式，但是这是我当时能够最有效的代码控制的方式了，因为经过自己的实践证明，这种方式可以合理规避掉各种的代码覆盖冲突等问题。至今还对于用BeyondCompare一行行比对代码的事记忆犹新啊。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="http://xidianpanpei.github.io/categories/Git/"/>
    
    
      <category term="git" scheme="http://xidianpanpei.github.io/tags/git/"/>
    
      <category term="代码管理" scheme="http://xidianpanpei.github.io/tags/%E4%BB%A3%E7%A0%81%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>基础算法之快速排序</title>
    <link href="http://xidianpanpei.github.io/2013/08/17/quick-sort/"/>
    <id>http://xidianpanpei.github.io/2013/08/17/quick-sort/</id>
    <published>2013-08-17T19:16:00.000Z</published>
    <updated>2017-11-13T11:34:53.946Z</updated>
    
    <content type="html"><![CDATA[<p>今天又是翻了一下「算法导论」中的「快速排序」，在记忆中，似乎记得这是实际应用中使用的最多的排序算法了，尽管它并不是一个很稳当的排序算法。「快速排序」的平均性能看起来是非常好的，但是它不稳定，因而坏起来的话，那也是非常糟糕的。对于「快速排序」来说，我们只能对它的期望时间复杂度做出估计：Ο(nlgn)。</p><p>「算法导论」中给出了「快速排序」以下的伪码实现，说实话，我并不是很喜欢这种写法，因为有时候这种方式很容易让人看晕了，还不如实际代码来的直接明了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PARTITION(A, p, r)</span><br><span class="line">x = A[r]</span><br><span class="line">i = p - <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j = p to r<span class="number">-1</span></span><br><span class="line">    <span class="keyword">if</span> A[j] &lt;= x</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        exchange A[i] with A[j]</span><br><span class="line">exchange A[i + <span class="number">1</span>] with A[r]</span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">QUICKSORT(A, p, r)</span><br><span class="line"><span class="keyword">if</span> p &lt; r</span><br><span class="line">    q = PARTITION(A, p, r)</span><br><span class="line">    QUICKSORT(A, p, q - <span class="number">1</span>)</span><br><span class="line">    QUICKSORT(A, q + <span class="number">1</span>, r)</span><br></pre></td></tr></table></figure><a id="more"></a>        <p>接下来就是用Java实现了这种排序算法，当然，形式有些不同，或者说是有些优化或者简化吧，这种形式似乎是在严奶奶那本书中有记载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> crazylion</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> key = a[left];</span><br><span class="line">            <span class="keyword">int</span> low = left;</span><br><span class="line">            <span class="keyword">int</span> high = right;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(low &lt; high &amp;&amp; a[high] &gt; key)</span><br><span class="line">                &#123;</span><br><span class="line">                    high--;</span><br><span class="line">                &#125;</span><br><span class="line">                a[low] = a[high];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">while</span>(low &lt; high &amp;&amp; a[low] &lt; key)</span><br><span class="line">                &#123;</span><br><span class="line">                    low++;</span><br><span class="line">                &#125;</span><br><span class="line">                a[high] = a[low];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            a[low] = key;</span><br><span class="line">            </span><br><span class="line">            quickSort(a, left, low - <span class="number">1</span>);</span><br><span class="line">            quickSort(a, low + <span class="number">1</span>, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp[i] = (<span class="keyword">int</span>) (Math.random()*<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="string">"==&gt;"</span> + temp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"================================"</span>);</span><br><span class="line">        </span><br><span class="line">        SortTest sortTest = <span class="keyword">new</span> SortTest();</span><br><span class="line">        sortTest.quickSort(temp, <span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"--&gt;"</span> + temp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码是经过实际运行的，效果还是不错滴！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天又是翻了一下「算法导论」中的「快速排序」，在记忆中，似乎记得这是实际应用中使用的最多的排序算法了，尽管它并不是一个很稳当的排序算法。「快速排序」的平均性能看起来是非常好的，但是它不稳定，因而坏起来的话，那也是非常糟糕的。对于「快速排序」来说，我们只能对它的期望时间复杂度做出估计：Ο(nlgn)。&lt;/p&gt;
&lt;p&gt;「算法导论」中给出了「快速排序」以下的伪码实现，说实话，我并不是很喜欢这种写法，因为有时候这种方式很容易让人看晕了，还不如实际代码来的直接明了。&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;PARTITION(A, p, r)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;x = A[r]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;i = p - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; j = p to r&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; A[j] &amp;lt;= x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        i = i + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        exchange A[i] with A[j]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;exchange A[i + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] with A[r]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; i + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;QUICKSORT(A, p, r)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; p &amp;lt; r&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    q = PARTITION(A, p, r)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QUICKSORT(A, p, q - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    QUICKSORT(A, q + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, r)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法" scheme="http://xidianpanpei.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://xidianpanpei.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="快速排序" scheme="http://xidianpanpei.github.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>基础算法之堆排序</title>
    <link href="http://xidianpanpei.github.io/2013/08/15/heap-sort/"/>
    <id>http://xidianpanpei.github.io/2013/08/15/heap-sort/</id>
    <published>2013-08-15T18:46:00.000Z</published>
    <updated>2017-11-13T11:34:53.942Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直都是比较闲的状态中，毕竟还是在过暑假嘛。于是拿起那本自从买来就没看过的「算法导论」看看，以前在网上总是看见将这本书推荐给入门的新人，不得不说这真的有点坑人的。</p><p>今天才刚刚拿起来，直接忽略第一部分的所谓「基础知识」，其实是看到那么多非基础的知识一下在看不下去了。看了下「堆排序」的章节，顺便回忆了一下以前学习的「堆排序」的知识。</p><p>「堆」无外乎就是一个特殊的完全二叉树，其特殊性在于堆的每个子树的根节点的值为该子树中的最大值/最小值，对应的堆就定义为「大顶堆/小顶堆」。「堆排序」的时间复杂度为O(nlgn)，这在排序算法中还是一个不错的时间复杂度的。接下来就是用代码实现了一下「堆排序」，这是不得不说下「算法导论」中的伪码还是不错的，至少比严奶奶的那本「数据结构」要强多了，但是这样的伪码有点不利于代码的实现，估计是太过于简要了吧。</p><a id="more"></a><p>我是用的Java实现，其实是找了网上的其他代码参照着书本的伪码改写的，其中还因为忘记了Java中没有引用这种东西的，导致调试代码调了好长时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> crazylion</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapAdjust</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> lchild = <span class="number">2</span>*i;</span><br><span class="line"><span class="keyword">int</span> rchild = <span class="number">2</span>*i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> max = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i &lt;= size/<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(lchild &lt;= size &amp;&amp; a[lchild] &gt; a[max])</span><br><span class="line">&#123;</span><br><span class="line">max = lchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(rchild &lt;= size &amp;&amp; a[rchild] &gt; a[max])</span><br><span class="line">&#123;</span><br><span class="line">max = rchild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(max != i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//因为Java没有引用，只能多写点了</span></span><br><span class="line"><span class="keyword">int</span> tmp = a[i];</span><br><span class="line">a[i] = a[max];</span><br><span class="line">a[max] = tmp;</span><br><span class="line">heapAdjust(a, max, size);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bulidHeap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = size/<span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">heapAdjust(a, i, size);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">bulidHeap(a, size);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = size; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//因为Java没有引用，只能多写点了</span></span><br><span class="line"><span class="keyword">int</span> tmp = a[<span class="number">1</span>];</span><br><span class="line">a[<span class="number">1</span>] = a[i];</span><br><span class="line">a[i] = tmp;</span><br><span class="line">heapAdjust(a, <span class="number">1</span>, i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] heap = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">heap[i] = (<span class="keyword">int</span>) (Math.random()*<span class="number">1000</span>);</span><br><span class="line">System.out.println(<span class="string">"==&gt;"</span> + heap[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SortTest sortTest = <span class="keyword">new</span> SortTest();</span><br><span class="line">sortTest.heapSort(heap, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"--&gt;"</span> + heap[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近一直都是比较闲的状态中，毕竟还是在过暑假嘛。于是拿起那本自从买来就没看过的「算法导论」看看，以前在网上总是看见将这本书推荐给入门的新人，不得不说这真的有点坑人的。&lt;/p&gt;
&lt;p&gt;今天才刚刚拿起来，直接忽略第一部分的所谓「基础知识」，其实是看到那么多非基础的知识一下在看不下去了。看了下「堆排序」的章节，顺便回忆了一下以前学习的「堆排序」的知识。&lt;/p&gt;
&lt;p&gt;「堆」无外乎就是一个特殊的完全二叉树，其特殊性在于堆的每个子树的根节点的值为该子树中的最大值/最小值，对应的堆就定义为「大顶堆/小顶堆」。「堆排序」的时间复杂度为O(nlgn)，这在排序算法中还是一个不错的时间复杂度的。接下来就是用代码实现了一下「堆排序」，这是不得不说下「算法导论」中的伪码还是不错的，至少比严奶奶的那本「数据结构」要强多了，但是这样的伪码有点不利于代码的实现，估计是太过于简要了吧。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://xidianpanpei.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://xidianpanpei.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="堆排序" scheme="http://xidianpanpei.github.io/tags/%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>骑行·安庆闲逛</title>
    <link href="http://xidianpanpei.github.io/2013/07/17/biking-around-anqing/"/>
    <id>http://xidianpanpei.github.io/2013/07/17/biking-around-anqing/</id>
    <published>2013-07-17T13:51:00.000Z</published>
    <updated>2017-11-13T11:34:53.938Z</updated>
    
    <content type="html"><![CDATA[<p>最近到处折腾了一番，终于也是回到家休息一下了。这几年，一直在<a href="http://weibo.com/inxian" target="_blank" rel="external">西安</a>学习工作，似乎也是在家待得很少的。这回算是彻底的离开<a href="http://weibo.com/inxian" target="_blank" rel="external">西安</a>了，结果就是回到家暂时休整一番吧。当然，我那辆Warrior550也就跟着回家闲着了。</p><p>车子自从寄回家后，一直也就没有拆封组装，前两天闲着没事才慢慢组装起来（PS:在这儿不得不抱怨下<a href="http://www.zto.cn" target="_blank" rel="external">中通快递</a>了，车子回来后也就看看有没有什么明显的伤痕，发现没什么事也就没管了，结果装车的时候才发现前轮的快拆轴给摔弯的不成样子，只好慢慢掰直了暂时先顶着。有了此次教训，以后寄车还是小心的为好了。），昨天乘着刚下过雨，天气荫凉的，同时也是在家闲的太过无聊了，骑着车出去转了一下。没有什么特别的感受，至少觉得安庆城还是挺小的，一个多小时就把老城区给转了一圈了。</p><p>骑行途中去了母校一中逛了一下，发现还是没怎么变化，只是前面的教学楼不知是翻新还是重建中。同时跑到长江边看看，只觉得江水真的不太干净啊，估计这几年的污染还是很严重啊。</p><a id="more"></a><p>「骑行路线」</p><p><img src="http://ww3.sinaimg.cn/large/7458d655gw1f70ojv0w0bj20sg0hon3r.jpg" alt=""></p><p>「母校闲逛」</p><p><img src="http://ww3.sinaimg.cn/large/7458d655gw1f70ojzvw19j20m80goagq.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/7458d655gw1f70ok76sz4j20m80godon.jpg" alt=""></p><p><img src="http://ww2.sinaimg.cn/large/7458d655gw1f70ok0m8rpj20m80goafi.jpg" alt=""></p><p><img src="http://ww4.sinaimg.cn/large/7458d655gw1f70ok52s1hj20m80go7bx.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/7458d655gw1f70ok4yq2qj20m80gowlz.jpg" alt=""></p><p><img src="http://ww4.sinaimg.cn/large/7458d655gw1f70ok6ztr3j20m80godo6.jpg" alt=""></p><p><img src="http://ww4.sinaimg.cn/large/7458d655gw1f70okb096zj20go0m8tkt.jpg" alt=""></p><p><img src="http://ww2.sinaimg.cn/large/7458d655gw1f70okabemvj20m80goqet.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/7458d655gw1f70ok8rpb3j20m80go118.jpg" alt=""></p><p><img src="http://ww2.sinaimg.cn/large/7458d655gw1f70okay3vfj20m80gogvk.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/7458d655gw1f70ok6b65mj20m80go46v.jpg" alt=""></p><p>「江边一瞥」</p><p><img src="http://ww3.sinaimg.cn/large/7458d655gw1f70ok34nssj20m80go0xu.jpg" alt=""></p><p><img src="http://ww4.sinaimg.cn/large/7458d655gw1f70ok0532pj20m80go42t.jpg" alt=""></p><p><img src="http://ww1.sinaimg.cn/large/7458d655gw1f70ojyfgcdj20m80gon2l.jpg" alt=""></p><p><img src="http://ww2.sinaimg.cn/large/7458d655gw1f70ojy7emyj20m70f4wir.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近到处折腾了一番，终于也是回到家休息一下了。这几年，一直在&lt;a href=&quot;http://weibo.com/inxian&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;西安&lt;/a&gt;学习工作，似乎也是在家待得很少的。这回算是彻底的离开&lt;a href=&quot;http://weibo.com/inxian&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;西安&lt;/a&gt;了，结果就是回到家暂时休整一番吧。当然，我那辆Warrior550也就跟着回家闲着了。&lt;/p&gt;
&lt;p&gt;车子自从寄回家后，一直也就没有拆封组装，前两天闲着没事才慢慢组装起来（PS:在这儿不得不抱怨下&lt;a href=&quot;http://www.zto.cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;中通快递&lt;/a&gt;了，车子回来后也就看看有没有什么明显的伤痕，发现没什么事也就没管了，结果装车的时候才发现前轮的快拆轴给摔弯的不成样子，只好慢慢掰直了暂时先顶着。有了此次教训，以后寄车还是小心的为好了。），昨天乘着刚下过雨，天气荫凉的，同时也是在家闲的太过无聊了，骑着车出去转了一下。没有什么特别的感受，至少觉得安庆城还是挺小的，一个多小时就把老城区给转了一圈了。&lt;/p&gt;
&lt;p&gt;骑行途中去了母校一中逛了一下，发现还是没怎么变化，只是前面的教学楼不知是翻新还是重建中。同时跑到长江边看看，只觉得江水真的不太干净啊，估计这几年的污染还是很严重啊。&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="http://xidianpanpei.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="骑行" scheme="http://xidianpanpei.github.io/tags/%E9%AA%91%E8%A1%8C/"/>
    
      <category term="安庆" scheme="http://xidianpanpei.github.io/tags/%E5%AE%89%E5%BA%86/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之观察者模式</title>
    <link href="http://xidianpanpei.github.io/2013/07/04/design-patterns-observer-mode/"/>
    <id>http://xidianpanpei.github.io/2013/07/04/design-patterns-observer-mode/</id>
    <published>2013-07-04T16:19:00.000Z</published>
    <updated>2017-11-13T11:34:53.942Z</updated>
    
    <content type="html"><![CDATA[<p>##题记<br>最近开始阅读<code>《Head First设计模式》</code>，所以有必要把自己学到的东西用blog的方式给记录下来，其中，大部分的源码和UML关系图均是来自于该书。在此，本系列的文章只是将学到的知识记录一下，必要的地方会加上个人的理解。</p><p>##正文<br>在我们的开发过程中，难免会遇到一种情况：存在一个主要对象，其他的对象因为由于数据的关系，必须依赖于这个对象产生的数据，但这个对象的数据总是处于不断的话当中，因此，我们希望这个主要对象的数据一旦发生变化，那么就能够及时的通知到依赖于它的对象。而当我们取消了这种依赖之后，随之而来就是不用再去通知已经取消的对象。其实，这个很像现在的<code>微信公众平台</code>，只要我们关注了某个公众账号后，公众账号就会不断的去推送最新的消息给关注者，而一旦取消关注后，这些推送也就中断了。在设计模式中，我们把这种行为称之为<code>观察者模式（observer pattern）</code>。</p><p>对于观察者模式，我们有着这样的书面定义：</p><blockquote><p>观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</p></blockquote><a id="more"></a><p>观察者有着如下的类图：</p><p><img src="/img/2013/07/04/observer-mode-1.png" alt=""></p><p>其实这么看的话，也是不清不楚的，这个只是给出了观察者模式的一种通用类图，而至于如何具体的运作，我们也是不甚了解。</p><p>以下就是以天气通知为例，利用具体代码具体说明整个观察者模式。</p><p><img src="/img/2013/07/04/WeatherData-1.png" alt=""></p><p>其中，<code>Subject</code>为主题对象接口，也就是前面所说的数据变化的源头，其他对象都是它的观察者；<code>Observer</code>为观察者接口；<code>DisplayElement</code>为显示接口，这个由于每个观察者对于显示有着不同的要求，因此独立开辟这样一个接口。<code>WeatherData</code>继承了<code>Subject</code>接口，生成了具体的主题对象，而观察者真正观察到的数据，就是由该具体对象提供。<code>CurrentConditonsDisplay</code>、<code>ForecastDisplay</code>、<code>StatisticsDisplay</code>、<code>ThirdPartydDisplay</code>这几个则是真正的观察者，当主题对象的数据产生了变化之后，就会主动的一一通知到这些个观察者，然后由它们根据各自的显示需求显示相应的数据（由于显示要求的不同，因此它们也继承显示接口<code>DisplayElement</code>）。</p><p>下面就让我们看看具体的运作代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//观察对象接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//观察者接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DisplayElement</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上定义各个接口，以及其中需要继承的公用方法，下面就是各个具体对象的实现了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList observers;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        observers = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = observers.indexof(o);</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            observers.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Observer o)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; observers.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Observer observer = (Observer)observers.get(i);</span><br><span class="line">            observer.update(temperature, humidity, pressure);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measurementsChanged</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMeasurements</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        measurementsChanged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// WeatherData的其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个是主题对象的具体实现<code>WeatherData</code>，它继承了<code>Subject</code>接口，其中具体实现了各个方法，其中<code>setMeasurements()</code>方法则是保证了在发生了变化时，第一时间能够将数据的变化通知到各个观察者。接下来，就是等着实现各个观察者了，这里只拿一个观察者<code>CurrentConditonsDisplay</code>作为实现的案例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditonsDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span>, <span class="title">DisplayElement</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> Subject weatherData;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CurrentConditonsDisplay</span><span class="params">(Subject weatherData)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.weatherData = weatherData;</span><br><span class="line">        weatherData.registerObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Current conditions: "</span> + temperature + <span class="string">"F degree and "</span> + humidity + <span class="string">"% humidity"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码似乎没有什么好说道的，唯一的特殊的地方就是在构建方法中，我们调用<code>Subject</code>对象，这在注册观察者时用到了，其实，在后期如果我们加上取消关注的时候，也是会用到这个对象的，所以从方便的角度考虑，我们在构造方法中调用了该对象。</p><p>剩下来就是个简单的测试代码了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">WeatherStation</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        WeatherData weatherData = <span class="keyword">new</span> WeatherData();</span><br><span class="line">        CurrentConditonsDisplay currentDisplay = <span class="keyword">new</span> CurrentConditonsDisplay(weatherData);</span><br><span class="line">        StatisticsDisplay statisticsDisplay = <span class="keyword">new</span> StatisticsDisplay(weatherData);</span><br><span class="line">        ForecastDisplay forecastDisplay = <span class="keyword">new</span> ForecastDisplay(weatherData);</span><br><span class="line"></span><br><span class="line">        weatherData.setMeasurements(<span class="number">80</span>, <span class="number">65</span>, <span class="number">30.4f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们理清了这些调用继承关系之后，豁然发现观察者模式其实挺简单的。而观察者模式的最重要的地方，就是在有一个主动数据源，多个被动读取数据的对象的情况下，让数据的操作变得单一简单，不会出现太多的对象操作数据的情况。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##题记&lt;br&gt;最近开始阅读&lt;code&gt;《Head First设计模式》&lt;/code&gt;，所以有必要把自己学到的东西用blog的方式给记录下来，其中，大部分的源码和UML关系图均是来自于该书。在此，本系列的文章只是将学到的知识记录一下，必要的地方会加上个人的理解。&lt;/p&gt;
&lt;p&gt;##正文&lt;br&gt;在我们的开发过程中，难免会遇到一种情况：存在一个主要对象，其他的对象因为由于数据的关系，必须依赖于这个对象产生的数据，但这个对象的数据总是处于不断的话当中，因此，我们希望这个主要对象的数据一旦发生变化，那么就能够及时的通知到依赖于它的对象。而当我们取消了这种依赖之后，随之而来就是不用再去通知已经取消的对象。其实，这个很像现在的&lt;code&gt;微信公众平台&lt;/code&gt;，只要我们关注了某个公众账号后，公众账号就会不断的去推送最新的消息给关注者，而一旦取消关注后，这些推送也就中断了。在设计模式中，我们把这种行为称之为&lt;code&gt;观察者模式（observer pattern）&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于观察者模式，我们有着这样的书面定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;观察者模式定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://xidianpanpei.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://xidianpanpei.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
